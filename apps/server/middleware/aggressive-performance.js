/** * AGGRESSIVE PERFORMANCE OPTIMIZATION MIDDLEWARE *  * This middleware implements aggressive performance optimizations specifically * targeting page load speed issues: * - Resource preloading and prefetching * - Critical CSS inlining * - JavaScript optimization and lazy loading * - Image optimization and lazy loading * - HTTP/2 server push * - Advanced caching strategies * - Bundle splitting and compression */const fs = require('fs-extra');const path = require('path');const zlib = require('zlib');const crypto = require('crypto');class AggressivePerformanceOptimizer {  constructor(options = {}) {    this.config = {      // Critical resource optimization      inlineCriticalCSS: options.inlineCriticalCSS !== false,      preloadCriticalResources: options.preloadCriticalResources !== false,      lazyLoadImages: options.lazyLoadImages !== false,      // JavaScript optimization      deferNonCriticalJS: options.deferNonCriticalJS !== false,      minifyInlineJS: options.minifyInlineJS !== false,      bundleOptimization: options.bundleOptimization !== false,      // Caching optimization      aggressiveCaching: options.aggressiveCaching !== false,      serviceWorkerEnabled: options.serviceWorkerEnabled !== false,      // Compression      brotliCompression: options.brotliCompression !== false,      precompressAssets: options.precompressAssets !== false,      // HTTP/2 optimization      serverPush: options.serverPush !== false,      // Paths      clientPath: options.clientPath || path.join(__dirname, '../../client'),      cachePath: options.cachePath || path.join(__dirname, '../cache/optimized')    };    // Cache for optimized resources    this.optimizedCache = new Map();    this.criticalCSS = new Map();    this.resourceHashes = new Map();    this.initializeOptimizations();  }  async initializeOptimizations() {    await fs.ensureDir(this.config.cachePath);    if (this.config.inlineCriticalCSS) {      await this.extractCriticalCSS();    }    if (this.config.precompressAssets) {      await this.precompressStaticAssets();    }  }  // Main middleware function  middleware() {    return async (req, res, next) => {      // Only optimize HTML responses      if (!req.path.endsWith('.html') && !req.path.endsWith('/')) {        return next();      }      const originalSend = res.send;      res.send = async (content) => {        if (res.get('Content-Type')?.includes('text/html')) {          try {            content = await this.optimizeHTML(content, req);          } catch (error) {            console.error('HTML optimization error:', error);          }        }        return originalSend.call(res, content);      };      // Set aggressive caching headers      this.setPerformanceHeaders(res, req);      next();    };  }  // Optimize HTML content  async optimizeHTML(html, req) {    let optimizedHTML = html;    // 1. Inline critical CSS    if (this.config.inlineCriticalCSS) {      optimizedHTML = await this.inlineCriticalCSS(optimizedHTML, req.path);    }    // 2. Add resource preloading    if (this.config.preloadCriticalResources) {      optimizedHTML = this.addResourcePreloading(optimizedHTML);    }    // 3. Optimize images for lazy loading    if (this.config.lazyLoadImages) {      optimizedHTML = this.optimizeImagesForLazyLoading(optimizedHTML);    }    // 4. Defer non-critical JavaScript    if (this.config.deferNonCriticalJS) {      optimizedHTML = this.deferNonCriticalJavaScript(optimizedHTML);    }    // 5. Add performance optimizations    optimizedHTML = this.addPerformanceOptimizations(optimizedHTML);    // 6. Minify HTML    optimizedHTML = this.minifyHTML(optimizedHTML);    return optimizedHTML;  }  // Extract and cache critical CSS  async extractCriticalCSS() {    const criticalStyles = `      /* Critical CSS for above-the-fold content */      body { font-family: 'Inter', sans-serif; margin: 0; padding: 0; }      .glass { background: rgba(255,255,255,0.9); backdrop-filter: blur(15px); }      .brand-gradient { background: linear-gradient(135deg, #0e2038 0%, #23325c 50%, #1e3a8a 100%); }      header { position: sticky; top: 0; z-index: 50; }      .loading-shimmer {         background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);         background-size: 200% 100%;         animation: shimmer 1.5s infinite;       }      @keyframes shimmer { 0% { background-position: -200% 0; } 100% { background-position: 200% 0; } }      .fade-in { animation: fadeIn 0.6s ease-out; }      @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }      /* Hide non-critical content initially */      .below-fold { opacity: 0; }    `;    this.criticalCSS.set('default', criticalStyles);  }  // Inline critical CSS  async inlineCriticalCSS(html, path) {    const criticalCSS = this.criticalCSS.get('default') || '';    // Remove external Tailwind CSS and replace with critical CSS    html = html.replace(      /<script src="https:\/\/cdn\.tailwindcss\.com"><\/script>/g,      `<style id="critical-css">${criticalCSS}</style>       <link rel="preload" href="https://cdn.tailwindcss.com" as="script" onload="this.onload=null;this.rel='script'">       <noscript><script src="https://cdn.tailwindcss.com"></script></noscript>`    );    return html;  }  // Add resource preloading  addResourcePreloading(html) {    const preloadLinks = `      <!-- Critical resource preloading -->      <link rel="preload" href="/shared/auth-utils.js" as="script">      <link rel="preload" href="/public/images/logo.png" as="image">      <link rel="preconnect" href="https://fonts.googleapis.com">      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>      <link rel="dns-prefetch" href="//cdn.tailwindcss.com">      <!-- Prefetch likely next pages -->      <link rel="prefetch" href="/auth/auth-buyer.html">      <link rel="prefetch" href="/buyer/dashboard.html">      <link rel="prefetch" href="/seller/dashboard.html">    `;    return html.replace('<head>', `<head>${preloadLinks}`);  }  // Optimize images for lazy loading  optimizeImagesForLazyLoading(html) {    // Add loading="lazy" to images and implement intersection observer    html = html.replace(      /<img([^>]*?)src="([^"]*?)"([^>]*?)>/g,      (match, before, src, after) => {        // Skip logo and critical images        if (src.includes('logo.png') || before.includes('critical')) {          return match;        }        return `<img${before}data-src="${src}" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1 1'%3E%3C/svg%3E" loading="lazy" class="lazy-image"${after}>`;      }    );    // Add lazy loading script    const lazyLoadScript = `      <script>        // Intersection Observer for lazy loading        if ('IntersectionObserver' in window) {          const imageObserver = new IntersectionObserver((entries, observer) => {            entries.forEach(entry => {              if (entry.isIntersecting) {                const img = entry.target;                img.src = img.dataset.src;                img.classList.remove('lazy-image');                img.classList.add('fade-in');                observer.unobserve(img);              }            });          }, { rootMargin: '50px' });          document.addEventListener('DOMContentLoaded', () => {            document.querySelectorAll('.lazy-image').forEach(img => imageObserver.observe(img));          });        }      </script>    `;    return html.replace('</body>', `${lazyLoadScript}</body>`);  }  // Defer non-critical JavaScript  deferNonCriticalJavaScript(html) {    // Make non-critical scripts async/defer    html = html.replace(      /<script src="([^"]*?)"(?!\s*defer)(?!\s*async)><\/script>/g,      (match, src) => {        // Keep critical scripts synchronous        if (src.includes('auth-utils') || src.includes('mode-switcher')) {          return `<script src="${src}" defer></script>`;        }        return `<script src="${src}" async></script>`;      }    );    return html;  }  // Add performance optimizations  addPerformanceOptimizations(html) {    const performanceScript = `      <script>        // Performance optimizations        (function() {          // Preload critical resources          const criticalResources = [            '/api/products?limit=12',            '/api/categories',            '/api/currency/rates'          ];          // Prefetch API data          if ('fetch' in window) {            setTimeout(() => {              criticalResources.forEach(url => {                fetch(url).then(response => response.json()).catch(() => {});              });            }, 100);          }          // Optimize font loading          if ('fonts' in document) {            document.fonts.load('400 16px Inter').then(() => {              document.body.classList.add('fonts-loaded');            });          }          // Progressive enhancement for below-fold content          const revealBelowFold = () => {            const elements = document.querySelectorAll('.below-fold');            elements.forEach(el => {              el.style.opacity = '1';              el.style.transition = 'opacity 0.3s ease-in';            });          };          // Reveal below-fold content after critical rendering          if (document.readyState === 'loading') {            document.addEventListener('DOMContentLoaded', () => {              setTimeout(revealBelowFold, 100);            });          } else {            setTimeout(revealBelowFold, 100);          }          // Service Worker registration          if ('serviceWorker' in navigator && '${this.config.serviceWorkerEnabled}' === 'true') {            window.addEventListener('load', () => {              navigator.serviceWorker.register('/sw.js').catch(() => {});            });          }        })();      </script>    `;    return html.replace('</head>', `${performanceScript}</head>`);  }  // Minify HTML  minifyHTML(html) {    return html      .replace(/\s+/g, ' ')      .replace(/>\s+</g, '><')      .replace(/\s+>/g, '>')      .replace(/<\s+/g, '<')      .trim();  }  // Set performance headers  setPerformanceHeaders(res, req) {    const isStatic = req.path.match(/\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$/);    if (isStatic) {      // Aggressive caching for static assets      res.set({        'Cache-Control': 'public, max-age=31536000, immutable',        'Expires': new Date(Date.now() + 31536000000).toUTCString()      });    } else {      // Smart caching for HTML      res.set({        'Cache-Control': 'public, max-age=300, stale-while-revalidate=86400',        'Vary': 'Accept-Encoding'      });    }    // Performance headers    res.set({      'X-Content-Type-Options': 'nosniff',      'X-Frame-Options': 'DENY',      'X-XSS-Protection': '1; mode=block',      'Referrer-Policy': 'strict-origin-when-cross-origin'    });    // HTTP/2 Server Push hints    if (req.httpVersion === '2.0' && this.config.serverPush) {      res.set('Link', [        '</shared/auth-utils.js>; rel=preload; as=script',        '</shared/mode-switcher.js>; rel=preload; as=script',        '</public/images/logo.png>; rel=preload; as=image'      ].join(', '));    }  }  // Precompress static assets  async precompressStaticAssets() {    const staticDirs = [      path.join(this.config.clientPath, 'public'),      path.join(this.config.clientPath, 'shared')    ];    for (const dir of staticDirs) {      if (await fs.pathExists(dir)) {        await this.compressDirectory(dir);      }    }  }  async compressDirectory(dir) {    const files = await fs.readdir(dir, { withFileTypes: true });    for (const file of files) {      const filePath = path.join(dir, file.name);      if (file.isDirectory()) {        await this.compressDirectory(filePath);      } else if (file.name.match(/\.(js|css|html|svg|json)$/)) {        await this.compressFile(filePath);      }    }  }  async compressFile(filePath) {    try {      const content = await fs.readFile(filePath);      // Gzip compression      const gzipped = zlib.gzipSync(content, { level: 9 });      await fs.writeFile(`${filePath}.gz`, gzipped);      // Brotli compression (if enabled)      if (this.config.brotliCompression && zlib.brotliCompressSync) {        const brotli = zlib.brotliCompressSync(content, {          params: {            [zlib.constants.BROTLI_PARAM_QUALITY]: 11,            [zlib.constants.BROTLI_PARAM_SIZE_HINT]: content.length          }        });        await fs.writeFile(`${filePath}.br`, brotli);      }    } catch (error) {      console.warn(`Failed to compress ${filePath}:`, error.message);    }  }  // Generate service worker  async generateServiceWorker() {    const swContent = `      const CACHE_NAME = 'add-physical-products-v1';      const CRITICAL_RESOURCES = [        '/',        '/shared/auth-utils.js',        '/public/images/logo.png',        '/shared/styles.css'      ];      self.addEventListener('install', event => {        event.waitUntil(          caches.open(CACHE_NAME)            .then(cache => cache.addAll(CRITICAL_RESOURCES))        );      });      self.addEventListener('fetch', event => {        if (event.request.method !== 'GET') return;        event.respondWith(          caches.match(event.request)            .then(response => {              if (response) return response;              return fetch(event.request).then(response => {                if (!response || response.status !== 200 || response.type !== 'basic') {                  return response;                }                const responseToCache = response.clone();                caches.open(CACHE_NAME)                  .then(cache => cache.put(event.request, responseToCache));                return response;              });            })        );      });    `;    const swPath = path.join(this.config.clientPath, 'public', 'sw.js');    await fs.writeFile(swPath, swContent);  }  // Static file middleware with precompressed support  static(options = {}) {    return (req, res, next) => {      const filePath = path.join(options.root || '', req.path);      const acceptEncoding = req.get('Accept-Encoding') || '';      // Try to serve precompressed files      if (acceptEncoding.includes('br') && fs.existsSync(`${filePath}.br`)) {        res.set('Content-Encoding', 'br');        res.set('Vary', 'Accept-Encoding');        return res.sendFile(`${filePath}.br`);      } else if (acceptEncoding.includes('gzip') && fs.existsSync(`${filePath}.gz`)) {        res.set('Content-Encoding', 'gzip');        res.set('Vary', 'Accept-Encoding');        return res.sendFile(`${filePath}.gz`);      }      next();    };  }}// Export factory functionmodule.exports = {  AggressivePerformanceOptimizer,  createAggressiveOptimizer: (options = {}) => {    const optimizer = new AggressivePerformanceOptimizer(options);    return {      middleware: optimizer.middleware(),      static: optimizer.static.bind(optimizer),      optimizer: optimizer    };  }};