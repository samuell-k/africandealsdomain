const express = require('express');
const router = express.Router();
const pool = require('../db');
const { requireAuth, requireRole } = require('./auth');
const multer = require('multer');
const path = require('path');
const fs = require('fs');

// Configure multer for screenshot uploads
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    const uploadsDir = path.join(__dirname, '../uploads/payment-screenshots');
    if (!fs.existsSync(uploadsDir)) {
      fs.mkdirSync(uploadsDir, { recursive: true });
    }
    cb(null, uploadsDir);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, 'payment-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({ 
  storage: storage,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Only image files are allowed'), false);
    }
  }
});

// Helper function to log payment actions
async function logPaymentAction(transactionId, action, details, userId, req) {
  try {
    await pool.execute(`
      INSERT INTO payment_logs (transaction_id, action, details, user_id, ip_address, user_agent)
      VALUES (?, ?, ?, ?, ?, ?)
    `, [
      transactionId,
      action,
      JSON.stringify(details),
      userId,
      req.ip || req.connection.remoteAddress,
      req.get('User-Agent') || null
    ]);
  } catch (error) {
    console.error('Error logging payment action:', error);
  }
}

// POST /api/payment-transactions - Create payment transaction

// ====================================================================
// ENHANCED ERROR HANDLING FOR /api/payment-transactions
// Auto-generated by Admin System Tester & Debugger
// ====================================================================

const enhancedErrorHandler = (routeHandler) => {
    return async (req, res, next) => {
        try {
            // Enhanced logging
            console.log(`📡 [ADMIN-API] ${req.method} ${req.originalUrl}`);
            console.log(`👤 [ADMIN-API] User: ${req.user?.email || 'unknown'} (Role: ${req.user?.role || 'unknown'})`);
            console.log(`📊 [ADMIN-API] Query params:`, req.query);
            console.log(`📦 [ADMIN-API] Body:`, req.body);
            
            const startTime = Date.now();
            
            await routeHandler(req, res, next);
            
            const duration = Date.now() - startTime;
            console.log(`⚡ [ADMIN-API] Request completed in ${duration}ms`);
            
        } catch (error) {
            const duration = Date.now() - startTime;
            
            // Comprehensive error logging
            console.error(`❌ [ADMIN-API] ERROR in ${req.method} ${req.originalUrl}`);
            console.error(`⏱️ [ADMIN-API] Failed after ${duration}ms`);
            console.error(`👤 [ADMIN-API] User: ${req.user?.email || 'unknown'}`);
            console.error(`💥 [ADMIN-API] Error details:`, {
                message: error.message,
                stack: error.stack,
                sql: error.sql || 'N/A',
                sqlMessage: error.sqlMessage || 'N/A',
                code: error.code || 'UNKNOWN',
                errno: error.errno || 'N/A'
            });
            
            // Save error to database for tracking
            try {
                const db = require('../db.js');
                await db.execute(`
                    INSERT INTO system_logs (level, message, details, created_at)
                    VALUES (?, ?, ?, NOW())
                `, [
                    'error',
                    `API Error: ${req.method} ${req.originalUrl}`,
                    JSON.stringify({
                        error: error.message,
                        stack: error.stack,
                        user: req.user?.email || 'unknown',
                        userAgent: req.headers['user-agent'],
                        ip: req.ip,
                        params: req.params,
                        query: req.query,
                        body: req.body
                    })
                ]);
            } catch (logError) {
                console.error('Failed to log error to database:', logError);
            }
            
            // User-friendly error response
            const isDevelopment = process.env.NODE_ENV === 'development';
            
            res.status(error.status || 500).json({
                success: false,
                message: error.message || 'Internal server error',
                error: isDevelopment ? {
                    message: error.message,
                    stack: error.stack,
                    details: error
                } : 'An unexpected error occurred. Please try again.',
                timestamp: new Date().toISOString(),
                requestId: req.headers['x-request-id'] || 'unknown'
            });
        }
    };
};


// ====================================================================
// ENHANCED ERROR HANDLING (DUPLICATE REMOVED)
// Auto-generated by Admin System Tester & Debugger
// ====================================================================

// enhancedErrorHandler already declared above, using existing one

router.post('/', requireAuth, async (req, res) => {
  try {
    const {
      order_id,
      payment_method_id,
      payment_type = 'automatic',
      amount,
      currency = 'USD'
    } = req.body;

    // Validate required fields
    if (!order_id || !amount) {
      return res.status(400).json({
        success: false,
        error: 'Order ID and amount are required'
      });
    }

    // Verify order exists and belongs to user
    const [orders] = await pool.execute(`
      SELECT id, user_id, total_amount, status 
      FROM orders 
      WHERE id = ? AND user_id = ?
    `, [order_id, req.user.id]);

    if (orders.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Order not found or access denied'
      });
    }

    const order = orders[0];

    // Verify amount matches order total
    if (parseFloat(amount) !== parseFloat(order.total_amount)) {
      return res.status(400).json({
        success: false,
        error: 'Payment amount does not match order total'
      });
    }

    // Create payment transaction
    const [result] = await pool.execute(`
      INSERT INTO payment_transactions (
        order_id, payment_method_id, payment_type, amount, currency, status
      ) VALUES (?, ?, ?, ?, ?, 'pending')
    `, [order_id, payment_method_id || null, payment_type, amount, currency]);

    const transactionId = result.insertId;

    // Log the action
    await logPaymentAction(transactionId, 'TRANSACTION_CREATED', {
      order_id,
      payment_method_id,
      payment_type,
      amount,
      currency
    }, req.user.id, req);

    res.status(201).json({
      success: true,
      transaction: {
        id: transactionId,
        order_id,
        payment_method_id,
        payment_type,
        amount,
        currency,
        status: 'pending'
      }
    });
  } catch (error) {
    console.error('Error creating payment transaction:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to create payment transaction'
    });
  }
});

// POST /api/payment-transactions/:id/manual-payment - Submit manual payment
router.post('/:id/manual-payment', requireAuth, upload.single('screenshot'), async (req, res) => {
  try {
    const transactionId = req.params.id;
    const {
      sender_name,
      sender_phone,
      transaction_id: userTransactionId
    } = req.body;

    // Validate required fields
    if (!sender_name || !sender_phone || !userTransactionId || !req.file) {
      return res.status(400).json({
        success: false,
        error: 'Sender name, phone, transaction ID, and screenshot are required'
      });
    }

    // Verify transaction exists and belongs to user
    const [transactions] = await pool.execute(`
      SELECT pt.*, o.user_id 
      FROM payment_transactions pt
      JOIN orders o ON pt.order_id = o.id
      WHERE pt.id = ? AND o.user_id = ?
    `, [transactionId, req.user.id]);

    if (transactions.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Transaction not found or access denied'
      });
    }

    const transaction = transactions[0];

    if (transaction.status !== 'pending') {
      return res.status(400).json({
        success: false,
        error: 'Transaction is not in pending status'
      });
    }

    const screenshotUrl = `/uploads/payment-screenshots/${req.file.filename}`;

    // Update transaction with manual payment details
    await pool.execute(`
      UPDATE payment_transactions 
      SET 
        payment_type = 'manual',
        status = 'pending_confirmation',
        sender_name = ?,
        sender_phone = ?,
        transaction_id = ?,
        screenshot_url = ?,
        updated_at = NOW()
      WHERE id = ?
    `, [sender_name, sender_phone, userTransactionId, screenshotUrl, transactionId]);

    // Log the action
    await logPaymentAction(transactionId, 'MANUAL_PAYMENT_SUBMITTED', {
      sender_name,
      sender_phone,
      transaction_id: userTransactionId,
      screenshot_url: screenshotUrl
    }, req.user.id, req);

    res.json({
      success: true,
      message: 'Manual payment submitted successfully. Please wait for admin confirmation.',
      status: 'pending_confirmation'
    });
  } catch (error) {
    console.error('Error submitting manual payment:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to submit manual payment'
    });
  }
});

// GET /api/payment-transactions - Get payment transactions (admin only)
router.get('/', requireAuth, requireRole('admin'), async (req, res) => {
  try {
    const { status, payment_type, page = 1, limit = 20 } = req.query;
    
    let query = `
      SELECT 
        pt.*,
        o.order_number,
        o.user_id as buyer_id,
        u.name as buyer_name,
        u.email as buyer_email,
        pm.method_name as payment_method_name,
        admin.name as processed_by_name
      FROM payment_transactions pt
      JOIN orders o ON pt.order_id = o.id
      JOIN users u ON o.user_id = u.id
      LEFT JOIN payment_methods pm ON pt.payment_method_id = pm.id
      LEFT JOIN users admin ON pt.processed_by = admin.id
      WHERE 1=1
    `;
    
    const params = [];
    
    if (status) {
      query += ' AND pt.status = ?';
      params.push(status);
    }
    
    if (payment_type) {
      query += ' AND pt.payment_type = ?';
      params.push(payment_type);
    }
    
    query += ' ORDER BY pt.created_at DESC';
    
    // Add pagination
    const offset = (parseInt(page) - 1) * parseInt(limit);
    query += ' LIMIT ? OFFSET ?';
    params.push(parseInt(limit), offset);
    
    const [transactions] = await pool.execute(query, params);
    
    res.json({
      success: true,
      transactions,
      page: parseInt(page),
      limit: parseInt(limit)
    });
  } catch (error) {
    console.error('Error fetching payment transactions:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch payment transactions'
    });
  }
});

// GET /api/payment-transactions/:id - Get specific transaction
router.get('/:id', requireAuth, async (req, res) => {
  try {
    const transactionId = req.params.id;
    
    let query = `
      SELECT 
        pt.*,
        o.order_number,
        o.user_id as buyer_id,
        u.name as buyer_name,
        u.email as buyer_email,
        pm.method_name as payment_method_name,
        admin.name as processed_by_name
      FROM payment_transactions pt
      JOIN orders o ON pt.order_id = o.id
      JOIN users u ON o.user_id = u.id
      LEFT JOIN payment_methods pm ON pt.payment_method_id = pm.id
      LEFT JOIN users admin ON pt.processed_by = admin.id
      WHERE pt.id = ?
    `;
    
    const params = [transactionId];
    
    // Non-admin users can only see their own transactions
    if (req.user.role !== 'admin') {
      query += ' AND o.user_id = ?';
      params.push(req.user.id);
    }
    
    const [transactions] = await pool.execute(query, params);
    
    if (transactions.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Transaction not found or access denied'
      });
    }
    
    // Get transaction logs if admin
    let logs = [];
    if (req.user.role === 'admin') {
      const [logRows] = await pool.execute(`
        SELECT pl.*, u.name as user_name
        FROM payment_logs pl
        LEFT JOIN users u ON pl.user_id = u.id
        WHERE pl.transaction_id = ?
        ORDER BY pl.created_at DESC
      `, [transactionId]);
      logs = logRows;
    }
    
    res.json({
      success: true,
      transaction: transactions[0],
      logs
    });
  } catch (error) {
    console.error('Error fetching payment transaction:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch payment transaction'
    });
  }
});

// POST /api/payment-transactions/:id/approve - Approve manual payment (admin only)
router.post('/:id/approve', requireAuth, requireRole('admin'), async (req, res) => {
  try {
    const transactionId = req.params.id;
    const { admin_notes } = req.body;

    // Verify transaction exists and is pending confirmation
    const [transactions] = await pool.execute(`
      SELECT pt.*, o.id as order_id
      FROM payment_transactions pt
      JOIN orders o ON pt.order_id = o.id
      WHERE pt.id = ? AND pt.status = 'pending_confirmation'
    `, [transactionId]);

    if (transactions.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Transaction not found or not pending confirmation'
      });
    }

    // Update transaction status
    await pool.execute(`
      UPDATE payment_transactions 
      SET 
        status = 'completed',
        admin_notes = ?,
        processed_by = ?,
        processed_at = NOW(),
        updated_at = NOW()
      WHERE id = ?
    `, [admin_notes || null, req.user.id, transactionId]);

    // Update order payment status
    await pool.execute(`
      UPDATE orders 
      SET payment_status = 'paid'
      WHERE id = ?
    `, [transactions[0].order_id]);

    // Log the action
    await logPaymentAction(transactionId, 'PAYMENT_APPROVED', {
      admin_notes,
      approved_by: req.user.id
    }, req.user.id, req);

    res.json({
      success: true,
      message: 'Payment approved successfully'
    });
  } catch (error) {
    console.error('Error approving payment:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to approve payment'
    });
  }
});

// POST /api/payment-transactions/:id/reject - Reject manual payment (admin only)
router.post('/:id/reject', requireAuth, requireRole('admin'), async (req, res) => {
  try {
    const transactionId = req.params.id;
    const { admin_notes } = req.body;

    if (!admin_notes) {
      return res.status(400).json({
        success: false,
        error: 'Admin notes are required for rejection'
      });
    }

    // Verify transaction exists and is pending confirmation
    const [transactions] = await pool.execute(`
      SELECT pt.*, o.id as order_id
      FROM payment_transactions pt
      JOIN orders o ON pt.order_id = o.id
      WHERE pt.id = ? AND pt.status = 'pending_confirmation'
    `, [transactionId]);

    if (transactions.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Transaction not found or not pending confirmation'
      });
    }

    // Update transaction status
    await pool.execute(`
      UPDATE payment_transactions 
      SET 
        status = 'rejected',
        admin_notes = ?,
        processed_by = ?,
        processed_at = NOW(),
        updated_at = NOW()
      WHERE id = ?
    `, [admin_notes, req.user.id, transactionId]);

    // Log the action
    await logPaymentAction(transactionId, 'PAYMENT_REJECTED', {
      admin_notes,
      rejected_by: req.user.id
    }, req.user.id, req);

    res.json({
      success: true,
      message: 'Payment rejected successfully'
    });
  } catch (error) {
    console.error('Error rejecting payment:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to reject payment'
    });
  }
});

// GET /api/payment-transactions/pending/count - Get pending transactions count (admin only)
router.get('/pending/count', requireAuth, requireRole('admin'), async (req, res) => {
  try {
    const [result] = await pool.execute(`
      SELECT COUNT(*) as count
      FROM payment_transactions
      WHERE status = 'pending_confirmation'
    `);

    res.json({
      success: true,
      pending_count: result[0].count
    });
  } catch (error) {
    console.error('Error fetching pending count:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch pending count'
    });
  }
});

// GET /api/payment-transactions/stats - Get payment statistics (admin only)
router.get('/stats', requireAuth, requireRole('admin'), async (req, res) => {
  try {
    // Get pending count
    const [pendingResult] = await pool.execute(`
      SELECT COUNT(*) as count
      FROM payment_transactions
      WHERE status = 'pending_confirmation'
    `);

    // Get approved today count
    const [approvedTodayResult] = await pool.execute(`
      SELECT COUNT(*) as count
      FROM payment_transactions
      WHERE status = 'completed' 
      AND DATE(processed_at) = CURDATE()
    `);

    // Get rejected today count
    const [rejectedTodayResult] = await pool.execute(`
      SELECT COUNT(*) as count
      FROM payment_transactions
      WHERE status = 'failed' 
      AND DATE(processed_at) = CURDATE()
    `);

    // Get total pending amount
    const [totalAmountResult] = await pool.execute(`
      SELECT COALESCE(SUM(amount), 0) as total
      FROM payment_transactions
      WHERE status = 'pending_confirmation'
    `);

    res.json({
      success: true,
      stats: {
        pending: pendingResult[0].count,
        approved_today: approvedTodayResult[0].count,
        rejected_today: rejectedTodayResult[0].count,
        total_amount: parseFloat(totalAmountResult[0].total)
      }
    });
  } catch (error) {
    console.error('Error fetching payment stats:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch payment statistics'
    });
  }
});

module.exports = router;