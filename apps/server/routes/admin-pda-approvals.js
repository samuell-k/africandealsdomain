/**
 * Admin PDA Approval Routes
 * Handles admin approval workflows for manual payments, payouts, and exceptions
 */

const express = require('express');
const router = express.Router();
const db = require('../db');
const { requireAuth } = require('./auth');
const pdaLogistics = require('../services/pdaLogisticsService');

// Middleware to verify admin access
const requireAdmin = async (req, res, next) => {
  try {
    if (req.user.role !== 'admin') {
      return res.status(403).json({ 
        error: 'Admin access required',
        userRole: req.user.role
      });
    }
    next();
  } catch (error) {
    console.error('[ADMIN-PDA] Admin verification error:', error);
    res.status(500).json({ error: 'Server error during admin verification' });
  }
};

/**
 * GET /api/admin/pda-approvals/pending
 * Get all pending admin approvals
 */

// ====================================================================
// ENHANCED ERROR HANDLING FOR /api/admin/pda-approvals/pending
// Auto-generated by Admin System Tester & Debugger
// ====================================================================

const enhancedErrorHandler = (routeHandler) => {
    return async (req, res, next) => {
        try {
            // Enhanced logging
            console.log(`ðŸ“¡ [ADMIN-API] ${req.method} ${req.originalUrl}`);
            console.log(`ðŸ‘¤ [ADMIN-API] User: ${req.user?.email || 'unknown'} (Role: ${req.user?.role || 'unknown'})`);
            console.log(`ðŸ“Š [ADMIN-API] Query params:`, req.query);
            console.log(`ðŸ“¦ [ADMIN-API] Body:`, req.body);
            
            const startTime = Date.now();
            
            await routeHandler(req, res, next);
            
            const duration = Date.now() - startTime;
            console.log(`âš¡ [ADMIN-API] Request completed in ${duration}ms`);
            
        } catch (error) {
            const duration = Date.now() - startTime;
            
            // Comprehensive error logging
            console.error(`âŒ [ADMIN-API] ERROR in ${req.method} ${req.originalUrl}`);
            console.error(`â±ï¸ [ADMIN-API] Failed after ${duration}ms`);
            console.error(`ðŸ‘¤ [ADMIN-API] User: ${req.user?.email || 'unknown'}`);
            console.error(`ðŸ’¥ [ADMIN-API] Error details:`, {
                message: error.message,
                stack: error.stack,
                sql: error.sql || 'N/A',
                sqlMessage: error.sqlMessage || 'N/A',
                code: error.code || 'UNKNOWN',
                errno: error.errno || 'N/A'
            });
            
            // Save error to database for tracking
            try {
                const db = require('../db.js');
                await db.execute(`
                    INSERT INTO system_logs (level, message, details, created_at)
                    VALUES (?, ?, ?, NOW())
                `, [
                    'error',
                    `API Error: ${req.method} ${req.originalUrl}`,
                    JSON.stringify({
                        error: error.message,
                        stack: error.stack,
                        user: req.user?.email || 'unknown',
                        userAgent: req.headers['user-agent'],
                        ip: req.ip,
                        params: req.params,
                        query: req.query,
                        body: req.body
                    })
                ]);
            } catch (logError) {
                console.error('Failed to log error to database:', logError);
            }
            
            // User-friendly error response
            const isDevelopment = process.env.NODE_ENV === 'development';
            
            res.status(error.status || 500).json({
                success: false,
                message: error.message || 'Internal server error',
                error: isDevelopment ? {
                    message: error.message,
                    stack: error.stack,
                    details: error
                } : 'An unexpected error occurred. Please try again.',
                timestamp: new Date().toISOString(),
                requestId: req.headers['x-request-id'] || 'unknown'
            });
        }
    };
};


router.get('/pending', requireAuth, requireAdmin, async (req, res) => {
  try {
    const { type, status = 'pending', limit = 100 } = req.query;

    let whereClause = 'WHERE 1=1';
    let queryParams = [];

    // Filter by status (support 'all' to fetch every status)
    if (status && status !== 'all') {
      whereClause += ' AND aa.status = ?';
      queryParams.push(status);
    }

    // Filter by approval type (support empty to get all)
    if (type) {
      whereClause += ' AND aa.approval_type = ?';
      queryParams.push(type);
    }

    const [approvals] = await db.execute(`
      SELECT 
        aa.*,
        o.order_number, o.total_amount, o.delivery_method, o.payment_proof AS o_payment_proof,
        requester.first_name as requester_first_name, 
        requester.last_name as requester_last_name,
        requester.username as requester_username,
        requester.email as requester_email,
        requester.phone as requester_phone,
        buyer.first_name as buyer_first_name, 
        buyer.last_name as buyer_last_name,
        buyer.phone as buyer_phone,
        seller.first_name as seller_first_name, 
        seller.last_name as seller_last_name,
        seller.phone as seller_phone
      FROM admin_approvals aa
      LEFT JOIN orders o ON aa.order_id = o.id
      LEFT JOIN users requester ON aa.requested_by = requester.id
      LEFT JOIN users buyer ON o.user_id = buyer.id
      LEFT JOIN users seller ON o.seller_id = seller.id
      ${whereClause}
      ORDER BY aa.created_at DESC
      LIMIT ?
    `, [...queryParams, parseInt(limit)]);

    // Process approvals and add computed fields
    const processedApprovals = approvals.map(approval => {
      // Construct requester name
      const requesterName = `${approval.requester_first_name || ''} ${approval.requester_last_name || ''}`.trim() || 
                           approval.requester_username || 'Unknown';
      
      // Construct buyer name
      const buyerName = `${approval.buyer_first_name || ''} ${approval.buyer_last_name || ''}`.trim() || 'Unknown';
      
      // Construct seller name
      const sellerName = `${approval.seller_first_name || ''} ${approval.seller_last_name || ''}`.trim() || 'Unknown';

      // Set payment proof URL if available; fall back to order.payment_proof
      let paymentProofUrl = null;
      const rawProof = approval.payment_proof || approval.o_payment_proof || approval.payment_proof_url;
      if (rawProof) {
        if (rawProof.startsWith('http')) {
          paymentProofUrl = rawProof;
        } else if (rawProof.startsWith('/uploads')) {
          paymentProofUrl = rawProof;
        } else {
          paymentProofUrl = `/uploads/${rawProof}`;
        }
      }

      return {
        ...approval,
        requester_name: requesterName,
        buyer_name: buyerName,
        seller_name: sellerName,
        payment_proof_url: paymentProofUrl,
        // Convert amount to FRW if needed
        amount: approval.amount || approval.total_amount || 0
      };
    });

    // Also include payment_proofs that may not yet be mirrored to admin_approvals
    let processedProofs = [];
    if (!type || type === 'MANUAL_PAYMENT') {
      let proofsWhere = 'WHERE 1=1';
      const proofsParams = [];
      if (status && status !== 'all') {
        proofsWhere += ' AND pp.status = ?';
        proofsParams.push(status);
      }

      const [proofs] = await db.execute(`
        SELECT 
          pp.id,
          pp.order_id,
          'MANUAL_PAYMENT' AS approval_type,
          pp.status,
          pp.screenshot_path AS payment_proof,
          pp.amount,
          pp.user_id AS requested_by,
          pp.created_at,
          o.order_number, o.total_amount, o.delivery_method, o.payment_proof AS o_payment_proof,
          requester.first_name as requester_first_name, 
          requester.last_name as requester_last_name,
          requester.username as requester_username,
          requester.email as requester_email,
          requester.phone as requester_phone,
          buyer.first_name as buyer_first_name, 
          buyer.last_name as buyer_last_name,
          buyer.phone as buyer_phone,
          seller.first_name as seller_first_name, 
          seller.last_name as seller_last_name,
          seller.phone as seller_phone
        FROM payment_proofs pp
        LEFT JOIN orders o ON pp.order_id = o.id
        LEFT JOIN users requester ON pp.user_id = requester.id
        LEFT JOIN users buyer ON o.user_id = buyer.id
        LEFT JOIN users seller ON o.seller_id = seller.id
        ${proofsWhere}
        ORDER BY pp.created_at DESC
        LIMIT ?
      `, [...proofsParams, parseInt(limit)]);

      processedProofs = proofs.map(approval => {
        const requesterName = `${approval.requester_first_name || ''} ${approval.requester_last_name || ''}`.trim() || 
                             approval.requester_username || 'Unknown';
        const buyerName = `${approval.buyer_first_name || ''} ${approval.buyer_last_name || ''}`.trim() || 'Unknown';
        const sellerName = `${approval.seller_first_name || ''} ${approval.seller_last_name || ''}`.trim() || 'Unknown';

        let paymentProofUrl = null;
        const rawProof = approval.payment_proof || approval.o_payment_proof || approval.payment_proof_url;
        if (rawProof) {
          if (rawProof.startsWith('http')) {
            paymentProofUrl = rawProof;
          } else if (rawProof.startsWith('/uploads')) {
            paymentProofUrl = rawProof;
          } else {
            paymentProofUrl = `/uploads/${rawProof}`;
          }
        }

        return {
          ...approval,
          requester_name: requesterName,
          buyer_name: buyerName,
          seller_name: sellerName,
          payment_proof_url: paymentProofUrl,
          amount: approval.amount || approval.total_amount || 0
        };
      });
    }

    // Include commission withdrawal requests for agents
    let commissionWithdrawals = [];
    if (!type || ['PDA_COMMISSION', 'FDA_COMMISSION', 'PSM_COMMISSION'].includes(type)) {
      let commissionWhere = 'WHERE 1=1';
      const commissionParams = [];
      
      if (status && status !== 'all') {
        commissionWhere += ' AND aw.status = ?';
        commissionParams.push(status);
      }
      
      if (type === 'PDA_COMMISSION') {
        commissionWhere += ' AND a.agent_type = "pickup_delivery"';
      } else if (type === 'FDA_COMMISSION') {
        commissionWhere += ' AND a.agent_type = "fast_delivery"';
      } else if (type === 'PSM_COMMISSION') {
        commissionWhere += ' AND a.agent_type = "pickup_site_manager"';
      }

      const [withdrawals] = await db.execute(`
        SELECT 
          aw.id,
          NULL as order_id,
          CASE 
            WHEN a.agent_type = 'pickup_delivery' THEN 'PDA_COMMISSION'
            WHEN a.agent_type = 'fast_delivery' THEN 'FDA_COMMISSION'
            WHEN a.agent_type = 'pickup_site_manager' THEN 'PSM_COMMISSION'
            ELSE 'AGENT_COMMISSION'
          END as approval_type,
          aw.status,
          NULL as payment_proof,
          aw.amount,
          aw.user_id as requested_by,
          aw.created_at,
          aw.updated_at,
          CONCAT('WD-', aw.id) as order_number,
          aw.amount as total_amount,
          'commission_withdrawal' as delivery_method,
          NULL as o_payment_proof,
          u.first_name as requester_first_name,
          u.last_name as requester_last_name,
          u.username as requester_username,
          u.email as requester_email,
          u.phone as requester_phone,
          u.first_name as buyer_first_name,
          u.last_name as buyer_last_name,
          u.phone as buyer_phone,
          NULL as seller_first_name,
          NULL as seller_last_name,
          NULL as seller_phone
        FROM agent_withdrawals aw
        LEFT JOIN agents a ON aw.agent_id = a.id
        LEFT JOIN users u ON aw.user_id = u.id
        ${commissionWhere}
        ORDER BY aw.created_at DESC
        LIMIT ?
      `, [...commissionParams, parseInt(limit)]);

      commissionWithdrawals = withdrawals.map(withdrawal => {
        const requesterName = `${withdrawal.requester_first_name || ''} ${withdrawal.requester_last_name || ''}`.trim() || 
                             withdrawal.requester_username || 'Unknown';
        
        return {
          ...withdrawal,
          requester_name: requesterName,
          buyer_name: requesterName,
          seller_name: 'N/A',
          payment_proof_url: null,
          amount: withdrawal.amount || 0
        };
      });
    }

    // Include seller payout requests
    let sellerPayouts = [];
    if (!type || type === 'SELLER_PAYOUT') {
      let sellerWhere = 'WHERE 1=1';
      const sellerParams = [];
      
      if (status && status !== 'all') {
        sellerWhere += ' AND sp.status = ?';
        sellerParams.push(status);
      }

      try {
        const [payouts] = await db.execute(`
          SELECT 
            sp.id,
            sp.order_id,
            'SELLER_PAYOUT' as approval_type,
            sp.status,
            NULL as payment_proof,
            sp.amount,
            sp.seller_id as requested_by,
            sp.created_at,
            sp.updated_at,
            o.order_number,
            sp.amount as total_amount,
            'seller_payout' as delivery_method,
            NULL as o_payment_proof,
            seller.first_name as requester_first_name,
            seller.last_name as requester_last_name,
            seller.username as requester_username,
            seller.email as requester_email,
            seller.phone as requester_phone,
            buyer.first_name as buyer_first_name,
            buyer.last_name as buyer_last_name,
            buyer.phone as buyer_phone,
            seller.first_name as seller_first_name,
            seller.last_name as seller_last_name,
            seller.phone as seller_phone
          FROM seller_payouts sp
          LEFT JOIN orders o ON sp.order_id = o.id
          LEFT JOIN users seller ON sp.seller_id = seller.id
          LEFT JOIN users buyer ON o.user_id = buyer.id
          ${sellerWhere}
          ORDER BY sp.created_at DESC
          LIMIT ?
        `, [...sellerParams, parseInt(limit)]);

        sellerPayouts = payouts.map(payout => {
          const requesterName = `${payout.requester_first_name || ''} ${payout.requester_last_name || ''}`.trim() || 
                               payout.requester_username || 'Unknown';
          const buyerName = `${payout.buyer_first_name || ''} ${payout.buyer_last_name || ''}`.trim() || 'Unknown';
          const sellerName = `${payout.seller_first_name || ''} ${payout.seller_last_name || ''}`.trim() || 'Unknown';
          
          return {
            ...payout,
            requester_name: requesterName,
            buyer_name: buyerName,
            seller_name: sellerName,
            payment_proof_url: null,
            amount: payout.amount || 0
          };
        });
      } catch (sellerError) {
        console.warn('[ADMIN-PDA] Seller payouts table may not exist:', sellerError.message);
      }
    }

    // Merge, sort, and limit results
    const combined = [...processedApprovals, ...processedProofs, ...commissionWithdrawals, ...sellerPayouts]
      .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
      .slice(0, parseInt(limit));

    // Get statistics (keep server-side minimal; client computes per currentApprovals)
    const [stats] = await db.execute(`
      SELECT 
        approval_type,
        COUNT(*) as count
      FROM admin_approvals 
      WHERE status = 'pending'
      GROUP BY approval_type
    `);

    const approvalStats = {
      MANUAL_PAYMENT: 0,
      SELLER_PAYOUT: 0,
      PSM_PAYMENT_APPROVAL: 0,
      PSM_COMMISSION: 0,
      PDA_COMMISSION: 0,
      FDA_COMMISSION: 0
    };

    stats.forEach(stat => {
      approvalStats[stat.approval_type] = stat.count;
    });

    res.json({
      success: true,
      message: 'Approvals retrieved successfully',
      approvals: combined,
      stats: approvalStats,
      total: combined.length
    });

  } catch (error) {
    console.error('[ADMIN-PDA] Error fetching pending approvals:', error);
    res.status(500).json({ 
      success: false,
      message: 'Failed to fetch pending approvals',
      error: error.message 
    });
  }
});

/**
 * GET /api/admin/pda-approvals/:approvalId
 * Get individual approval details
 */
router.get('/:approvalId', requireAuth, requireAdmin, async (req, res) => {
  try {
    const approvalId = req.params.approvalId;

    const [approvals] = await db.execute(`
      SELECT 
        aa.*,
        o.order_number, o.total_amount, o.delivery_method, o.payment_proof,
        requester.first_name as requester_first_name, 
        requester.last_name as requester_last_name,
        requester.username as requester_username,
        requester.email as requester_email,
        requester.phone as requester_phone,
        buyer.first_name as buyer_first_name, 
        buyer.last_name as buyer_last_name,
        buyer.phone as buyer_phone,
        seller.first_name as seller_first_name, 
        seller.last_name as seller_last_name,
        seller.phone as seller_phone,
        reviewer.first_name as reviewer_first_name,
        reviewer.last_name as reviewer_last_name,
        reviewer.email as reviewer_email
      FROM admin_approvals aa
      LEFT JOIN orders o ON aa.order_id = o.id
      LEFT JOIN users requester ON aa.requested_by = requester.id
      LEFT JOIN users buyer ON o.user_id = buyer.id
      LEFT JOIN users seller ON o.seller_id = seller.id
      LEFT JOIN users reviewer ON aa.reviewed_by = reviewer.id
      WHERE aa.id = ?
    `, [approvalId]);

    if (approvals.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Approval not found'
      });
    }

    const approval = approvals[0];

    // Process approval data
    const requesterName = `${approval.requester_first_name || ''} ${approval.requester_last_name || ''}`.trim() || 
                         approval.requester_username || 'Unknown';
    
    const buyerName = `${approval.buyer_first_name || ''} ${approval.buyer_last_name || ''}`.trim() || 'Unknown';
    const sellerName = `${approval.seller_first_name || ''} ${approval.seller_last_name || ''}`.trim() || 'Unknown';
    const reviewerName = `${approval.reviewer_first_name || ''} ${approval.reviewer_last_name || ''}`.trim() || null;

    // Set payment proof URL if available; fall back to order.payment_proof
    let paymentProofUrl = null;
    const rawProof = approval.payment_proof || approval.o_payment_proof || approval.payment_proof_url;
    if (rawProof) {
      if (rawProof.startsWith('http')) {
        paymentProofUrl = rawProof;
      } else if (rawProof.startsWith('/uploads')) {
        paymentProofUrl = rawProof;
      } else {
        paymentProofUrl = `/uploads/${rawProof}`;
      }
    }

    const processedApproval = {
      ...approval,
      requester_name: requesterName,
      buyer_name: buyerName,
      seller_name: sellerName,
      reviewer_name: reviewerName,
      payment_proof_url: paymentProofUrl,
      amount: approval.amount || approval.total_amount || 0
    };

    res.json({
      success: true,
      message: 'Approval details retrieved successfully',
      approval: processedApproval
    });

  } catch (error) {
    console.error('[ADMIN-PDA] Error fetching approval details:', error);
    res.status(500).json({ 
      success: false,
      message: 'Failed to fetch approval details',
      error: error.message 
    });
  }
});

/**
 * POST /api/admin/pda-approvals/:approvalId/approve
 * Approve a pending request
 */
router.post('/:approvalId/approve', requireAuth, requireAdmin, async (req, res) => {
  try {
    const approvalId = req.params.approvalId;
    const { reviewNotes, review_notes, notes } = req.body;
    const adminId = req.user.id;
    const finalNotes = reviewNotes || review_notes || notes || 'Approved by admin';

    const connection = await db.getConnection();
    try {
      await connection.beginTransaction();

      // First try to find in admin_approvals
      const [approvals] = await connection.execute(`
        SELECT * FROM admin_approvals WHERE id = ? AND status = 'pending'
      `, [approvalId]);

      let approval = null;
      let approvalSource = 'admin_approvals';

      if (approvals.length > 0) {
        approval = approvals[0];
      } else {
        // Try to find in payment_proofs table
        const [paymentProofs] = await connection.execute(`
          SELECT *, 'MANUAL_PAYMENT' as approval_type FROM payment_proofs WHERE id = ? AND status = 'pending'
        `, [approvalId]);
        
        if (paymentProofs.length > 0) {
          approval = paymentProofs[0];
          approvalSource = 'payment_proofs';
        } else {
          // Try to find in agent_withdrawals table
          const [withdrawals] = await connection.execute(`
            SELECT aw.*, 
                   CASE 
                     WHEN a.agent_type = 'pickup_delivery' THEN 'PDA_COMMISSION'
                     WHEN a.agent_type = 'fast_delivery' THEN 'FDA_COMMISSION'
                     WHEN a.agent_type = 'pickup_site_manager' THEN 'PSM_COMMISSION'
                     ELSE 'AGENT_COMMISSION'
                   END as approval_type
            FROM agent_withdrawals aw
            LEFT JOIN agents a ON aw.agent_id = a.id
            WHERE aw.id = ? AND aw.status = 'pending'
          `, [approvalId]);
          
          if (withdrawals.length > 0) {
            approval = withdrawals[0];
            approvalSource = 'agent_withdrawals';
          }
        }
      }

      if (!approval) {
        await connection.rollback();
        return res.status(404).json({ error: 'Approval request not found or already processed' });
      }

      // Update approval status based on source
      if (approvalSource === 'admin_approvals') {
        await connection.execute(`
          UPDATE admin_approvals 
          SET status = 'approved', reviewed_by = ?, review_notes = ?, approved_at = NOW()
          WHERE id = ?
        `, [adminId, finalNotes, approvalId]);
      } else if (approvalSource === 'payment_proofs') {
        await connection.execute(`
          UPDATE payment_proofs 
          SET status = 'approved', reviewed_by = ?, admin_notes = ?, reviewed_at = NOW()
          WHERE id = ?
        `, [adminId, finalNotes, approvalId]);
      } else if (approvalSource === 'agent_withdrawals') {
        await connection.execute(`
          UPDATE agent_withdrawals 
          SET status = 'approved', processed_by = ?, admin_notes = ?, processed_at = NOW()
          WHERE id = ?
        `, [adminId, finalNotes, approvalId]);
      }

      // Handle different approval types
      switch (approval.approval_type) {
        case 'MANUAL_PAYMENT':
          // Approve manual payment and transition order status
          if (approval.order_id) {
            await connection.execute(`
              UPDATE orders 
              SET payment_status = 'confirmed',
                  status = CASE WHEN status = 'payment_submitted' THEN 'confirmed' ELSE status END,
                  updated_at = NOW()
              WHERE id = ?
            `, [approval.order_id]);
          }
          break;

        case 'SELLER_PAYOUT':
          // Release seller payout (update status fields and set amount if provided)
          await connection.execute(`
            UPDATE orders 
            SET seller_payout_status = 'released',
                seller_payout_released_at = NOW(),
                seller_payout_amount = COALESCE(seller_payout_amount, ?)
            WHERE id = ?
          `, [approval.amount || null, approval.order_id]);

          // Send notification to seller
          await connection.execute(`
            INSERT INTO enhanced_notifications 
            (user_id, user_role, notification_type, title, message, order_id, priority)
            SELECT seller_id, 'seller', 'PAYOUT_RELEASED', 
                   'Payment Released', 
                   CONCAT('Your payment for order ', order_number, ' has been released.'),
                   id, 'high'
            FROM orders WHERE id = ?
          `, [approval.order_id]);
          break;

        case 'PDA_COMMISSION':
        case 'FDA_COMMISSION':
        case 'PSM_COMMISSION':
          // Handle commission withdrawal approval
          if (approvalSource === 'agent_withdrawals') {
            // This is a withdrawal request, mark as completed
            await connection.execute(`
              UPDATE agent_withdrawals 
              SET status = 'completed', completed_at = NOW()
              WHERE id = ?
            `, [approvalId]);
            
            // Log the commission payout
            await connection.execute(`
              INSERT INTO admin_activity_logs (admin_id, action, details, created_at)
              VALUES (?, 'APPROVE_COMMISSION_WITHDRAWAL', ?, NOW())
            `, [adminId, `Approved ${approval.approval_type} withdrawal of ${approval.amount} FRW for agent ID ${approval.agent_id}`]);
          } else if (approval.order_id) {
            // This is an order-based commission release
            await connection.execute(`
              UPDATE orders 
              SET pda_commission_released = TRUE, pda_commission_released_at = NOW()
              WHERE id = ?
            `, [approval.order_id]);
          }
          break;



        case 'EXCEPTION_OVERRIDE':
          // Handle exception override (custom logic based on request data)
          const requestData = JSON.parse(approval.request_data || '{}');
          // Implement specific override logic based on exception type
          break;
      }

      // Optional: mark order complete when both seller payout and agent commission are released
      try {
        const [orderFlags] = await connection.execute(`
          SELECT 
            (seller_payout_status = 'released') AS seller_released,
            (fda_commission_status = 'released' OR pda_commission_released = TRUE) AS agent_released
          FROM orders WHERE id = ?
        `, [approval.order_id]);
        if (orderFlags.length > 0 && orderFlags[0].seller_released && orderFlags[0].agent_released) {
          await connection.execute(`
            UPDATE orders SET completed_at = COALESCE(completed_at, NOW()) WHERE id = ?
          `, [approval.order_id]);
        }
      } catch (e) {
        console.warn('[ADMIN-PDA] Post-approval completion check warning:', e.message);
      }

      await connection.commit();

      res.json({
        success: true,
        message: 'Approval processed successfully',
        approvalType: approval.approval_type,
        orderId: approval.order_id
      });

    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }

  } catch (error) {
    console.error('[ADMIN-PDA] Error processing approval:', error);
    res.status(500).json({ error: 'Failed to process approval' });
  }
});

/**
 * POST /api/admin/pda-approvals/:approvalId/reject
 * Reject a pending request
 */
router.post('/:approvalId/reject', requireAuth, requireAdmin, async (req, res) => {
  try {
    const approvalId = req.params.approvalId;
    const { reviewNotes, review_notes, notes, rejection_reason } = req.body;
    const adminId = req.user.id;
    const finalNotes = rejection_reason || reviewNotes || review_notes || notes;

    if (!finalNotes) {
      return res.status(400).json({ error: 'Review notes are required for rejection' });
    }

    const connection = await db.getConnection();
    try {
      await connection.beginTransaction();

      // First try to find in admin_approvals
      const [approvals] = await connection.execute(`
        SELECT * FROM admin_approvals WHERE id = ? AND status = 'pending'
      `, [approvalId]);

      let approval = null;
      let approvalSource = 'admin_approvals';

      if (approvals.length > 0) {
        approval = approvals[0];
      } else {
        // Try to find in payment_proofs table
        const [paymentProofs] = await connection.execute(`
          SELECT *, 'MANUAL_PAYMENT' as approval_type FROM payment_proofs WHERE id = ? AND status = 'pending'
        `, [approvalId]);
        
        if (paymentProofs.length > 0) {
          approval = paymentProofs[0];
          approvalSource = 'payment_proofs';
        } else {
          // Try to find in agent_withdrawals table
          const [withdrawals] = await connection.execute(`
            SELECT aw.*, 
                   CASE 
                     WHEN a.agent_type = 'pickup_delivery' THEN 'PDA_COMMISSION'
                     WHEN a.agent_type = 'fast_delivery' THEN 'FDA_COMMISSION'
                     WHEN a.agent_type = 'pickup_site_manager' THEN 'PSM_COMMISSION'
                     ELSE 'AGENT_COMMISSION'
                   END as approval_type
            FROM agent_withdrawals aw
            LEFT JOIN agents a ON aw.agent_id = a.id
            WHERE aw.id = ? AND aw.status = 'pending'
          `, [approvalId]);
          
          if (withdrawals.length > 0) {
            approval = withdrawals[0];
            approvalSource = 'agent_withdrawals';
          }
        }
      }

      if (!approval) {
        await connection.rollback();
        return res.status(404).json({ error: 'Approval request not found or already processed' });
      }

      // Update approval status based on source
      if (approvalSource === 'admin_approvals') {
        await connection.execute(`
          UPDATE admin_approvals 
          SET status = 'rejected', reviewed_by = ?, review_notes = ?
          WHERE id = ?
        `, [adminId, finalNotes, approvalId]);
      } else if (approvalSource === 'payment_proofs') {
        await connection.execute(`
          UPDATE payment_proofs 
          SET status = 'rejected', reviewed_by = ?, admin_notes = ?, reviewed_at = NOW()
          WHERE id = ?
        `, [adminId, finalNotes, approvalId]);
      } else if (approvalSource === 'agent_withdrawals') {
        await connection.execute(`
          UPDATE agent_withdrawals 
          SET status = 'rejected', processed_by = ?, admin_notes = ?, processed_at = NOW()
          WHERE id = ?
        `, [adminId, finalNotes, approvalId]);
      }

      // Send rejection notification to requester
      const requesterId = approval.requested_by || approval.user_id;
      if (requesterId) {
        try {
          await connection.execute(`
            INSERT INTO enhanced_notifications 
            (user_id, user_role, notification_type, title, message, order_id, priority)
            VALUES (?, 
                    COALESCE((SELECT role FROM users WHERE id = ?), 'user'), 
                    'ADMIN_ATTENTION_REQUIRED',
                    'Request Rejected',
                    ?,
                    ?, 'high')
          `, [
            requesterId,
            requesterId,
            `Your ${approval.approval_type} request has been rejected. Reason: ${finalNotes}`,
            approval.order_id || null
          ]);
        } catch (notificationError) {
          console.warn('[ADMIN-PDA] Failed to send rejection notification:', notificationError.message);
        }
      }

      // Handle rejection consequences based on approval type
      if (approval.approval_type === 'MANUAL_PAYMENT' && approval.order_id) {
        // Update order status if payment is rejected
        await connection.execute(`
          UPDATE orders 
          SET payment_status = 'rejected',
              status = CASE WHEN status = 'payment_submitted' THEN 'pending' ELSE status END,
              updated_at = NOW()
          WHERE id = ?
        `, [approval.order_id]);
      }

      // Log admin activity
      await connection.execute(`
        INSERT INTO admin_activity_logs (admin_id, action, details, created_at)
        VALUES (?, 'REJECT_APPROVAL', ?, NOW())
      `, [adminId, `Rejected ${approval.approval_type} request #${approvalId}: ${finalNotes}`]);

      await connection.commit();

      res.json({
        success: true,
        message: 'Request rejected successfully',
        approvalType: approval.approval_type,
        orderId: approval.order_id
      });

    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }

  } catch (error) {
    console.error('[ADMIN-PDA] Error rejecting approval:', error);
    res.status(500).json({ error: 'Failed to reject request' });
  }
});

/**
 * GET /api/admin/pda-approvals/orders/stuck
 * Get orders that may be stuck in the system
 */
router.get('/orders/stuck', requireAuth, requireAdmin, async (req, res) => {
  try {
    const { hoursThreshold = 24 } = req.query;

    const [stuckOrders] = await db.execute(`
      SELECT 
        o.id, o.order_number, o.status, o.delivery_method,
        o.created_at, o.updated_at,
        TIMESTAMPDIFF(HOUR, o.updated_at, NOW()) as hours_since_update,
        COALESCE(CONCAT(buyer.first_name, ' ', buyer.last_name), buyer.username, buyer.email) as buyer_name, buyer.phone as buyer_phone,
        COALESCE(CONCAT(seller.first_name, ' ', seller.last_name), seller.username, seller.email) as seller_name, seller.phone as seller_phone,
        COALESCE(CONCAT(agent.first_name, ' ', agent.last_name), agent.username, agent.email) as agent_name, agent.phone as agent_phone
      FROM orders o
      JOIN users buyer ON o.user_id = buyer.id
      JOIN users seller ON o.seller_id = seller.id
      LEFT JOIN users agent ON o.agent_id = agent.id
      WHERE o.status NOT IN ('completed', 'cancelled', 'disputed')
        AND TIMESTAMPDIFF(HOUR, o.updated_at, NOW()) > ?
      ORDER BY hours_since_update DESC
      LIMIT 100
    `, [parseInt(hoursThreshold)]);

    // Get latest status history for each stuck order
    for (let order of stuckOrders) {
      const [latestHistory] = await db.execute(`
        SELECT osh.*, u.name as changed_by_name
        FROM order_status_history osh
        JOIN users u ON osh.changed_by = u.id
        WHERE osh.order_id = ?
        ORDER BY osh.created_at DESC
        LIMIT 1
      `, [order.id]);
      order.latestStatusChange = latestHistory[0];

      // Get GPS tracking if available
      const [gpsData] = await db.execute(`
        SELECT latitude, longitude, accuracy, created_at
        FROM order_gps_tracking
        WHERE order_id = ?
        ORDER BY created_at DESC
        LIMIT 1
      `, [order.id]);
      order.latestGPS = gpsData[0];
    }

    res.json({
      success: true,
      stuckOrders,
      count: stuckOrders.length,
      thresholdHours: parseInt(hoursThreshold)
    });

  } catch (error) {
    console.error('[ADMIN-PDA] Error fetching stuck orders:', error);
    res.status(500).json({ error: 'Failed to fetch stuck orders' });
  }
});

/**
 * POST /api/admin/pda-approvals/orders/:orderId/manual-override
 * Manually override order status or resolve issues
 */
router.post('/orders/:orderId/manual-override', requireAuth, requireAdmin, async (req, res) => {
  try {
    const orderId = req.params.orderId;
    const { action, newStatus, reason, notifyParties = true } = req.body;
    const adminId = req.user.id;

    if (!action || !reason) {
      return res.status(400).json({ error: 'Action and reason are required' });
    }

    const connection = await db.getConnection();
    try {
      await connection.beginTransaction();

      // Create override approval record
      await connection.execute(`
        INSERT INTO admin_approvals 
        (approval_type, order_id, requested_by, reviewed_by, status, request_data, review_notes, approved_at)
        VALUES ('EXCEPTION_OVERRIDE', ?, ?, ?, 'approved', ?, ?, NOW())
      `, [
        orderId, adminId, adminId,
        JSON.stringify({ action, newStatus }),
        reason
      ]);

      let resultMessage = 'Manual override completed';

      switch (action) {
        case 'status_change':
          if (!newStatus) {
            throw new Error('New status is required for status change action');
          }
          await pdaLogistics.transitionOrderStatus(
            orderId,
            newStatus,
            adminId,
            { reason: `Admin manual override: ${reason}` }
          );
          resultMessage = `Order status changed to ${newStatus}`;
          break;

        case 'release_all_payouts':
          await connection.execute(`
            UPDATE orders 
            SET seller_payout_released = TRUE, 
                seller_payout_released_at = NOW(),
                pda_commission_released = TRUE,
                pda_commission_released_at = NOW()
            WHERE id = ?
          `, [orderId]);
          resultMessage = 'All payouts released';
          break;

        case 'cancel_order':
          await pdaLogistics.transitionOrderStatus(
            orderId,
            pdaLogistics.ORDER_STATUSES.CANCELLED,
            adminId,
            { reason: `Admin cancelled: ${reason}` }
          );
          resultMessage = 'Order cancelled';
          break;

        case 'complete_order':
          await pdaLogistics.transitionOrderStatus(
            orderId,
            pdaLogistics.ORDER_STATUSES.COMPLETED,
            adminId,
            { reason: `Admin completed: ${reason}` }
          );
          resultMessage = 'Order marked as completed';
          break;

        default:
          throw new Error('Invalid override action');
      }

      // Send notifications if requested
      if (notifyParties) {
        const [orderDetails] = await connection.execute(`
          SELECT user_id, seller_id, agent_id FROM orders WHERE id = ?
        `, [orderId]);

        if (orderDetails.length > 0) {
          const { user_id: buyerId, seller_id: sellerId, agent_id: agentId } = orderDetails[0];

          // Notify all parties
          const notifications = [
            { userId: buyerId, role: 'buyer' },
            { userId: sellerId, role: 'seller' },
            ...(agentId ? [{ userId: agentId, role: 'agent' }] : [])
          ];

          for (const { userId, role } of notifications) {
            await connection.execute(`
              INSERT INTO enhanced_notifications 
              (user_id, user_role, notification_type, title, message, order_id, priority)
              VALUES (?, ?, 'ADMIN_ATTENTION_REQUIRED', 'Order Update', ?, ?, 'high')
            `, [userId, role, `Admin has updated your order. ${resultMessage}. Reason: ${reason}`, orderId]);
          }
        }
      }

      await connection.commit();

      res.json({
        success: true,
        message: resultMessage,
        action,
        orderId
      });

    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }

  } catch (error) {
    console.error('[ADMIN-PDA] Error processing manual override:', error);
    res.status(500).json({ error: error.message || 'Failed to process manual override' });
  }
});

/**
 * GET /api/admin/pda-approvals/dashboard/stats
 * Get admin dashboard statistics
 */
router.get('/dashboard/stats', requireAuth, requireAdmin, async (req, res) => {
  try {
    // Get pending approvals count
    const [pendingApprovals] = await db.execute(`
      SELECT approval_type, COUNT(*) as count
      FROM admin_approvals
      WHERE status = 'pending'
      GROUP BY approval_type
    `);

    // Get orders by status (using status column instead of detailed_status)
    const [ordersByStatus] = await db.execute(`
      SELECT status, COUNT(*) as count
      FROM orders
      WHERE status NOT IN ('completed', 'cancelled')
      GROUP BY status
    `);

    // Get stuck orders count (using status column)
    const [stuckOrdersCount] = await db.execute(`
      SELECT COUNT(*) as count
      FROM orders
      WHERE status NOT IN ('completed', 'cancelled', 'disputed')
        AND TIMESTAMPDIFF(HOUR, updated_at, NOW()) > 24
    `);

    // Get today's completed orders (using status column)
    const [todayStats] = await db.execute(`
      SELECT 
        COUNT(*) as completed_orders,
        SUM(total_amount) as total_value,
        COUNT(DISTINCT agent_id) as active_agents
      FROM orders
      WHERE status = 'completed' AND DATE(updated_at) = CURDATE()
    `);

    res.json({
      success: true,
      stats: {
        pendingApprovals: pendingApprovals.reduce((acc, item) => {
          acc[item.approval_type] = item.count;
          return acc;
        }, {}),
        ordersByStatus: ordersByStatus.reduce((acc, item) => {
          acc[item.status] = item.count;
          return acc;
        }, {}),
        stuckOrdersCount: stuckOrdersCount[0].count,
        today: {
          completedOrders: todayStats[0].completed_orders || 0,
          totalValue: parseFloat(todayStats[0].total_value || 0),
          activeAgents: todayStats[0].active_agents || 0
        }
      }
    });

  } catch (error) {
    console.error('[ADMIN-PDA] Error fetching dashboard stats:', error);
    res.status(500).json({ error: 'Failed to fetch dashboard statistics' });
  }
});

// SPECIFIC ENDPOINTS FOR DIFFERENT APPROVAL TYPES

/**
 * GET /api/admin/pda-approvals/seller-payouts/pending
 * Get pending seller payout requests
 */
router.get('/seller-payouts/pending', requireAuth, requireAdmin, async (req, res) => {
  try {
    const { status = 'pending', limit = 100 } = req.query;
    
    // Set type filter and call the main pending handler
    req.query.type = 'SELLER_PAYOUT';
    
    // Call the main pending approvals logic
    const { type = null, status: queryStatus = 'pending', limit: queryLimit = 100 } = req.query;
    
    let whereClause = 'WHERE 1=1';
    const queryParams = [];
    
    if (queryStatus && queryStatus !== 'all') {
      whereClause += ' AND aa.status = ?';
      queryParams.push(queryStatus);
    }
    
    if (type) {
      whereClause += ' AND aa.approval_type = ?';
      queryParams.push(type);
    }

    const [approvals] = await db.execute(`
      SELECT 
        aa.*,
        o.order_number, o.total_amount, o.delivery_method, o.payment_proof AS o_payment_proof,
        requester.first_name as requester_first_name, 
        requester.last_name as requester_last_name,
        requester.username as requester_username,
        requester.email as requester_email,
        requester.phone as requester_phone,
        buyer.first_name as buyer_first_name, 
        buyer.last_name as buyer_last_name,
        buyer.phone as buyer_phone,
        seller.first_name as seller_first_name, 
        seller.last_name as seller_last_name,
        seller.phone as seller_phone
      FROM admin_approvals aa
      LEFT JOIN orders o ON aa.order_id = o.id
      LEFT JOIN users requester ON aa.requested_by = requester.id
      LEFT JOIN users buyer ON o.user_id = buyer.id
      LEFT JOIN users seller ON o.seller_id = seller.id
      ${whereClause}
      ORDER BY aa.created_at DESC
      LIMIT ?
    `, [...queryParams, parseInt(queryLimit)]);

    const processedApprovals = approvals.map(approval => {
      const requesterName = `${approval.requester_first_name || ''} ${approval.requester_last_name || ''}`.trim() || 
                           approval.requester_username || 'Unknown';
      const buyerName = `${approval.buyer_first_name || ''} ${approval.buyer_last_name || ''}`.trim() || 'Unknown';
      const sellerName = `${approval.seller_first_name || ''} ${approval.seller_last_name || ''}`.trim() || 'Unknown';

      return {
        ...approval,
        requester_name: requesterName,
        buyer_name: buyerName,
        seller_name: sellerName,
        payment_proof_url: null,
        amount: approval.amount || approval.total_amount || 0
      };
    });

    res.json({
      success: true,
      message: 'Seller payout requests retrieved successfully',
      approvals: processedApprovals,
      total: processedApprovals.length
    });
    
  } catch (error) {
    console.error('[ADMIN-PDA] Error fetching seller payouts:', error);
    res.status(500).json({ error: 'Failed to fetch seller payout requests' });
  }
});

/**
 * POST /api/admin/pda-approvals/seller-payouts/:id/approve
 * Approve seller payout request
 */
router.post('/seller-payouts/:id/approve', requireAuth, requireAdmin, async (req, res) => {
  try {
    const approvalId = req.params.id;
    const { reviewNotes, review_notes, notes } = req.body;
    const adminId = req.user.id;
    const finalNotes = reviewNotes || review_notes || notes || 'Approved by admin';

    const connection = await db.getConnection();
    try {
      await connection.beginTransaction();

      // Update approval status
      await connection.execute(`
        UPDATE admin_approvals 
        SET status = 'approved', reviewed_by = ?, review_notes = ?, approved_at = NOW()
        WHERE id = ? AND approval_type = 'SELLER_PAYOUT'
      `, [adminId, finalNotes, approvalId]);

      await connection.commit();

      res.json({
        success: true,
        message: 'Seller payout approved successfully'
      });

    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }

  } catch (error) {
    console.error('[ADMIN-PDA] Error approving seller payout:', error);
    res.status(500).json({ error: 'Failed to approve seller payout' });
  }
});

/**
 * POST /api/admin/pda-approvals/seller-payouts/:id/reject
 * Reject seller payout request
 */
router.post('/seller-payouts/:id/reject', requireAuth, requireAdmin, async (req, res) => {
  try {
    const approvalId = req.params.id;
    const { reviewNotes, review_notes, notes, rejection_reason } = req.body;
    const adminId = req.user.id;
    const finalNotes = rejection_reason || reviewNotes || review_notes || notes;

    if (!finalNotes) {
      return res.status(400).json({ error: 'Review notes are required for rejection' });
    }

    const connection = await db.getConnection();
    try {
      await connection.beginTransaction();

      // Update approval status
      await connection.execute(`
        UPDATE admin_approvals 
        SET status = 'rejected', reviewed_by = ?, review_notes = ?
        WHERE id = ? AND approval_type = 'SELLER_PAYOUT'
      `, [adminId, finalNotes, approvalId]);

      await connection.commit();

      res.json({
        success: true,
        message: 'Seller payout rejected successfully'
      });

    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }

  } catch (error) {
    console.error('[ADMIN-PDA] Error rejecting seller payout:', error);
    res.status(500).json({ error: 'Failed to reject seller payout' });
  }
});

// Note: The main /pending, /:approvalId/approve, and /:approvalId/reject endpoints
// handle all approval types including PDA_COMMISSION, FDA_COMMISSION, PSM_COMMISSION
// The admin frontend can use query parameters like ?type=PDA_COMMISSION to filter

module.exports = router;