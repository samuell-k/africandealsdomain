const express = require('express');
const router = express.Router();
const db = require('../db.js');
const bcrypt = require('bcrypt');
const { requireAuth, requireRole } = require('./auth.js');
const { sendTemplatedEmail } = require('../utils/mailer');

// ====================================================================
// ENHANCED ERROR HANDLING SYSTEM
// ====================================================================

const enhancedErrorHandler = (routeHandler) => {
    return async (req, res, next) => {
        const startTime = Date.now();
        
        try {
            // Enhanced logging
            console.log(`📡 [ADMIN-API] ${req.method} ${req.originalUrl}`);
            console.log(`👤 [ADMIN-API] User: ${req.user?.email || 'unknown'} (Role: ${req.user?.role || 'unknown'})`);
            console.log(`📊 [ADMIN-API] Query params:`, req.query);
            console.log(`📦 [ADMIN-API] Body:`, req.body);
            
            await routeHandler(req, res, next);
            
            const duration = Date.now() - startTime;
            console.log(`⚡ [ADMIN-API] Request completed in ${duration}ms`);
            
        } catch (error) {
            const duration = Date.now() - startTime;
            
            // Comprehensive error logging
            console.error(`❌ [ADMIN-API] ERROR in ${req.method} ${req.originalUrl}`);
            console.error(`⏱️ [ADMIN-API] Failed after ${duration}ms`);
            console.error(`👤 [ADMIN-API] User: ${req.user?.email || 'unknown'}`);
            console.error(`💥 [ADMIN-API] Error details:`, {
                message: error.message,
                stack: error.stack,
                sql: error.sql || 'N/A',
                sqlMessage: error.sqlMessage || 'N/A',
                code: error.code || 'UNKNOWN',
                errno: error.errno || 'N/A'
            });
            
            // Save error to database for tracking
            try {
                await db.execute(`
                    INSERT INTO system_logs (level, message, details, created_at)
                    VALUES (?, ?, ?, NOW())
                `, [
                    'error',
                    `API Error: ${req.method} ${req.originalUrl}`,
                    JSON.stringify({
                        error: error.message,
                        stack: error.stack,
                        user: req.user?.email || 'unknown',
                        userAgent: req.headers['user-agent'],
                        ip: req.ip,
                        params: req.params,
                        query: req.query,
                        body: req.body
                    })
                ]);
            } catch (logError) {
                console.error('Failed to log error to database:', logError);
            }
            
            // User-friendly error response
            const isDevelopment = process.env.NODE_ENV === 'development';
            
            res.status(error.status || 500).json({
                success: false,
                message: error.message || 'Internal server error',
                error: isDevelopment ? {
                    message: error.message,
                    stack: error.stack,
                    details: error
                } : 'An unexpected error occurred. Please try again.',
                timestamp: new Date().toISOString(),
                requestId: req.headers['x-request-id'] || 'unknown'
            });
        }
    };
};

console.log('🔧 [ADMIN ROUTER] Loading admin routes...');

// Apply authentication middleware to all admin routes
router.use(requireAuth);
router.use(requireRole('admin'));

console.log('🔧 [ADMIN ROUTER] Admin routes loaded successfully');

// ==================== DASHBOARD & ANALYTICS ====================

// GET /api/admin/dashboard - Dashboard statistics
router.get('/dashboard', enhancedErrorHandler(async (req, res) => {
    // Get real-time statistics
    const [userStats] = await db.execute(`
      SELECT 
        COUNT(*) as total_users,
        COUNT(CASE WHEN role = 'buyer' THEN 1 END) as total_buyers,
        COUNT(CASE WHEN role = 'seller' THEN 1 END) as total_sellers,
        COUNT(CASE WHEN role = 'agent' THEN 1 END) as total_agents,
        COUNT(CASE WHEN created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY) THEN 1 END) as new_users_week
      FROM users
    `);

    const [orderStats] = await db.execute(`
      SELECT 
        COUNT(*) as total_orders,
        COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_orders,
        COUNT(CASE WHEN status = 'processing' THEN 1 END) as processing_orders,
        COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_orders,
        COUNT(CASE WHEN created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY) THEN 1 END) as new_orders_week,
        COALESCE(SUM(total_amount), 0) as total_revenue
      FROM orders
    `);

    const [productStats] = await db.execute(`
      SELECT 
        COUNT(*) as total_products,
        COUNT(CASE WHEN status = 'active' THEN 1 END) as active_products,
        COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_products,
        COUNT(CASE WHEN created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY) THEN 1 END) as new_products_week
      FROM products
    `);

    const [paymentStats] = await db.execute(`
      SELECT 
        COUNT(*) as total_transactions,
        COUNT(CASE WHEN status = 'pending_confirmation' THEN 1 END) as pending_payments,
        COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_payments,
        COALESCE(SUM(CASE WHEN status = 'completed' THEN amount ELSE 0 END), 0) as total_payment_amount
      FROM payment_transactions
    `);

    // Get pending approvals count
    let approvalStats = [{ pending_approvals: 0, manual_payments: 0 }];
    try {
        [approvalStats] = await db.execute(`
          SELECT 
            COUNT(*) as pending_approvals,
            COUNT(CASE WHEN approval_type = 'MANUAL_PAYMENT' THEN 1 END) as manual_payments
          FROM admin_approvals 
          WHERE status = 'pending'
        `);
    } catch (error) {
        console.warn('admin_approvals table not available yet:', error.message);
    }

    // Recent activities
    const [recentActivities] = await db.execute(`
      SELECT 
        'user_registration' as type,
        CONCAT(username, ' registered as ', role) as description,
        created_at as timestamp
      FROM users 
      WHERE created_at >= DATE_SUB(NOW(), INTERVAL 24 HOUR)
      
      UNION ALL
      
      SELECT 
        'order_placed' as type,
        CONCAT('Order #', order_number, ' placed - $', total_amount) as description,
        created_at as timestamp
      FROM orders 
      WHERE created_at >= DATE_SUB(NOW(), INTERVAL 24 HOUR)
      
      ORDER BY timestamp DESC 
      LIMIT 10
    `);

    const dashboardData = {
      stats: {
        users: userStats[0],
        orders: orderStats[0],
        products: productStats[0],
        payments: paymentStats[0],
        approvals: approvalStats[0]
      },
      recent_activities: recentActivities,
      system_health: {
        database_status: 'healthy',
        last_updated: new Date().toISOString()
      }
    };

    res.json({
      success: true,
      message: 'Dashboard data retrieved successfully',
      ...dashboardData
    });
}));

// GET /api/admin/analytics - Advanced analytics
router.get('/analytics', enhancedErrorHandler(async (req, res) => {
    const { period = '30' } = req.query;
    
    // Daily statistics for the period
    const [dailyStats] = await db.execute(`
      SELECT 
        DATE(created_at) as date,
        COUNT(CASE WHEN table_name = 'users' THEN 1 END) as new_users,
        COUNT(CASE WHEN table_name = 'orders' THEN 1 END) as new_orders,
        COUNT(CASE WHEN table_name = 'products' THEN 1 END) as new_products
      FROM (
        SELECT created_at, 'users' as table_name FROM users WHERE created_at >= DATE_SUB(NOW(), INTERVAL ? DAY)
        UNION ALL
        SELECT created_at, 'orders' as table_name FROM orders WHERE created_at >= DATE_SUB(NOW(), INTERVAL ? DAY)
        UNION ALL
        SELECT created_at, 'products' as table_name FROM products WHERE created_at >= DATE_SUB(NOW(), INTERVAL ? DAY)
      ) combined
      GROUP BY DATE(created_at)
      ORDER BY date DESC
    `, [period, period, period]);

    // Revenue analytics
    const [revenueStats] = await db.execute(`
      SELECT 
        DATE(created_at) as date,
        COUNT(*) as order_count,
        SUM(total_amount) as daily_revenue,
        AVG(total_amount) as avg_order_value
      FROM orders 
      WHERE created_at >= DATE_SUB(NOW(), INTERVAL ? DAY)
      GROUP BY DATE(created_at)
      ORDER BY date DESC
    `, [period]);

    res.json({
      success: true,
      message: 'Analytics data retrieved successfully',
      analytics: {
        daily_stats: dailyStats,
        revenue_stats: revenueStats,
        period: `${period} days`
      }
    });
}));

// ==================== USER MANAGEMENT ====================

// GET /api/admin/users - Get all users with filtering
router.get('/users', enhancedErrorHandler(async (req, res) => {
    const { 
      role, 
      status, 
      search, 
      page = 1, 
      limit = 50,
      sort_by = 'created_at',
      sort_order = 'DESC'
    } = req.query;

    let whereConditions = [];
    let queryParams = [];

    // Build dynamic WHERE clause
    if (role) {
      whereConditions.push('role = ?');
      queryParams.push(role);
    }

    if (status) {
      if (status === 'active') {
        whereConditions.push('is_active = 1');
      } else if (status === 'inactive') {
        whereConditions.push('is_active = 0');
      }
    }

    if (search) {
      whereConditions.push('(username LIKE ? OR email LIKE ? OR first_name LIKE ? OR last_name LIKE ?)');
      const searchTerm = `%${search}%`;
      queryParams.push(searchTerm, searchTerm, searchTerm, searchTerm);
    }

    const whereClause = whereConditions.length > 0 ? 'WHERE ' + whereConditions.join(' AND ') : '';
    
    // Get total count
    const [countResult] = await db.execute(`
      SELECT COUNT(*) as total 
      FROM users 
      ${whereClause}
    `, queryParams);

    const totalUsers = countResult[0].total;
    const offset = (page - 1) * limit;

    // Get users with pagination
    const [users] = await db.execute(`
      SELECT 
        id, username, email, first_name, last_name, role, 
        is_active, is_verified, phone, created_at, updated_at
      FROM users 
      ${whereClause}
      ORDER BY ${sort_by} ${sort_order}
      LIMIT ? OFFSET ?
    `, [...queryParams, parseInt(limit), offset]);

    // Get total statistics for all users (not just filtered)
    const [totalStats] = await db.execute(`
      SELECT 
        COUNT(*) as total_users,
        COUNT(CASE WHEN role = 'buyer' THEN 1 END) as total_buyers,
        COUNT(CASE WHEN role = 'seller' THEN 1 END) as total_sellers,
        COUNT(CASE WHEN role = 'agent' THEN 1 END) as total_agents
      FROM users
    `);

    res.json({
      success: true,
      message: 'Users retrieved successfully',
      users: users,
      pagination: {
        current_page: parseInt(page),
        per_page: parseInt(limit),
        total: totalUsers,
        total_pages: Math.ceil(totalUsers / limit)
      },
      statistics: totalStats[0],
      filters: { role, status, search }
    });
}));

// GET /api/admin/users/:id - Get specific user details
router.get('/users/:id', enhancedErrorHandler(async (req, res) => {
    const { id } = req.params;

    const [users] = await db.execute(`
      SELECT 
        id, username, email, first_name, last_name, role, 
        is_active, is_verified, phone, created_at, updated_at
      FROM users 
      WHERE id = ?
    `, [id]);

    if (users.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    const user = users[0];

    // Get user's orders if they're a buyer
    let orders = [];
    if (user.role === 'buyer') {
      [orders] = await db.execute(`
        SELECT id, order_number, total_amount, status, created_at
        FROM orders 
        WHERE user_id = ?
        ORDER BY created_at DESC
        LIMIT 10
      `, [id]);
    }

    // Get user's products if they're a seller
    let products = [];
    if (user.role === 'seller') {
      [products] = await db.execute(`
        SELECT id, name, price, status, created_at
        FROM products 
        WHERE seller_id = ?
        ORDER BY created_at DESC
        LIMIT 10
      `, [id]);
    }

    res.json({
      success: true,
      message: 'User details retrieved successfully',
      user: user,
      orders: orders,
      products: products
    });
}));

// PUT /api/admin/users/:id/status - Update user status
router.put('/users/:id/status', enhancedErrorHandler(async (req, res) => {
    const { id } = req.params;
    const { status, reason } = req.body;

    if (!['active', 'inactive', 'suspended'].includes(status)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid status. Must be active, inactive, or suspended'
      });
    }

    const isActive = status === 'active' ? 1 : 0;

    await db.execute(`
      UPDATE users 
      SET is_active = ?, updated_at = NOW()
      WHERE id = ?
    `, [isActive, id]);

    // Log the status change
    await db.execute(`
      INSERT INTO system_logs (level, message, details, created_at)
      VALUES (?, ?, ?, NOW())
    `, [
      'info',
      `User status changed to ${status}`,
      JSON.stringify({
        user_id: id,
        new_status: status,
        reason: reason || 'No reason provided',
        changed_by: req.user.id,
        changed_by_email: req.user.email
      })
    ]);

    res.json({
      success: true,
      message: `User status updated to ${status} successfully`
    });
}));

// POST /api/admin/users - Create new user
router.post('/users', enhancedErrorHandler(async (req, res) => {
    const { 
      first_name, 
      last_name, 
      username, 
      email, 
      phone, 
      password, 
      role, 
      agent_type, 
      is_active = 1 
    } = req.body;

    // Validate required fields
    if (!first_name || !last_name || !username || !email || !password || !role) {
      return res.status(400).json({
        success: false,
        message: 'Missing required fields: first_name, last_name, username, email, password, role'
      });
    }

    // Validate agent type for agents
    if (role === 'agent' && !agent_type) {
      return res.status(400).json({
        success: false,
        message: 'Agent type is required for agent role'
      });
    }

    // Check if username or email already exists
    const [existingUsers] = await db.execute(
      'SELECT id FROM users WHERE username = ? OR email = ?', 
      [username, email]
    );

    if (existingUsers.length > 0) {
      return res.status(400).json({
        success: false,
        message: 'Username or email already exists'
      });
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create user
    const [result] = await db.execute(`
      INSERT INTO users (
        first_name, last_name, username, email, phone, password, 
        role, agent_type, is_active, is_verified, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 1, NOW(), NOW())
    `, [
      first_name, 
      last_name, 
      username, 
      email, 
      phone || null, 
      hashedPassword, 
      role, 
      role === 'agent' ? agent_type : null, 
      is_active
    ]);

    // Log user creation
    await db.execute(`
      INSERT INTO system_logs (level, message, details, created_at)
      VALUES (?, ?, ?, NOW())
    `, [
      'info',
      `New user created by admin`,
      JSON.stringify({
        new_user_id: result.insertId,
        username: username,
        email: email,
        role: role,
        agent_type: agent_type || null,
        created_by: req.user?.id || 'unknown',
        created_by_email: req.user?.email || 'unknown'
      })
    ]);

    res.status(201).json({
      success: true,
      message: 'User created successfully',
      user_id: result.insertId
    });
}));

// PUT /api/admin/users/:id - Update user
router.put('/users/:id', enhancedErrorHandler(async (req, res) => {
    const { id } = req.params;
    const { 
      first_name, 
      last_name, 
      username, 
      email, 
      phone, 
      role, 
      agent_type, 
      is_active 
    } = req.body;

    // Check if user exists
    const [existingUsers] = await db.execute('SELECT * FROM users WHERE id = ?', [id]);
    
    if (existingUsers.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    const existingUser = existingUsers[0];

    // Validate required fields
    if (!first_name || !last_name || !username || !email || !role) {
      return res.status(400).json({
        success: false,
        message: 'Missing required fields: first_name, last_name, username, email, role'
      });
    }

    // Validate agent type for agents
    if (role === 'agent' && !agent_type) {
      return res.status(400).json({
        success: false,
        message: 'Agent type is required for agent role'
      });
    }

    // Check if username or email already exists (excluding current user)
    const [duplicateUsers] = await db.execute(
      'SELECT id FROM users WHERE (username = ? OR email = ?) AND id != ?', 
      [username, email, id]
    );

    if (duplicateUsers.length > 0) {
      return res.status(400).json({
        success: false,
        message: 'Username or email already exists'
      });
    }

    // Update user
    await db.execute(`
      UPDATE users SET 
        first_name = ?, 
        last_name = ?, 
        username = ?, 
        email = ?, 
        phone = ?, 
        role = ?, 
        agent_type = ?, 
        is_active = ?, 
        updated_at = NOW()
      WHERE id = ?
    `, [
      first_name, 
      last_name, 
      username, 
      email, 
      phone || null, 
      role, 
      role === 'agent' ? agent_type : null, 
      is_active !== undefined ? is_active : existingUser.is_active,
      id
    ]);

    // Log user update
    await db.execute(`
      INSERT INTO system_logs (level, message, details, created_at)
      VALUES (?, ?, ?, NOW())
    `, [
      'info',
      `User updated by admin`,
      JSON.stringify({
        user_id: id,
        username: username,
        email: email,
        role: role,
        agent_type: agent_type || null,
        changes: {
          first_name: existingUser.first_name !== first_name,
          last_name: existingUser.last_name !== last_name,
          username: existingUser.username !== username,
          email: existingUser.email !== email,
          phone: existingUser.phone !== phone,
          role: existingUser.role !== role,
          agent_type: existingUser.agent_type !== agent_type,
          is_active: existingUser.is_active !== is_active
        },
        updated_by: req.user.id,
        updated_by_email: req.user.email
      })
    ]);

    res.json({
      success: true,
      message: 'User updated successfully'
    });
}));

// DELETE /api/admin/users/:id - Delete user (soft delete)
router.delete('/users/:id', enhancedErrorHandler(async (req, res) => {
    const { id } = req.params;
    const { reason } = req.body;

    // Check if user exists
    const [users] = await db.execute('SELECT id, email FROM users WHERE id = ?', [id]);
    
    if (users.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    // Soft delete by deactivating
    await db.execute(`
      UPDATE users 
      SET is_active = 0, updated_at = NOW()
      WHERE id = ?
    `, [id]);

    // Log the deletion
    await db.execute(`
      INSERT INTO system_logs (level, message, details, created_at)
      VALUES (?, ?, ?, NOW())
    `, [
      'warning',
      `User account deleted`,
      JSON.stringify({
        user_id: id,
        user_email: users[0].email,
        reason: reason || 'No reason provided',
        deleted_by: req.user.id,
        deleted_by_email: req.user.email
      })
    ]);

    res.json({
      success: true,
      message: 'User account deactivated successfully'
    });
}));

// ==================== PRODUCT MANAGEMENT ====================

// GET /api/admin/products - Get all products with filtering
router.get('/products', enhancedErrorHandler(async (req, res) => {
    const { 
      status, 
      category, 
      seller_id,
      search, 
      page = 1, 
      limit = 50,
      sort_by = 'created_at',
      sort_order = 'DESC'
    } = req.query;

    let whereConditions = [];
    let queryParams = [];

    if (status) {
      whereConditions.push('p.status = ?');
      queryParams.push(status);
    }

    if (category) {
      whereConditions.push('p.category_id = ?');
      queryParams.push(category);
    }

    if (seller_id) {
      whereConditions.push('p.seller_id = ?');
      queryParams.push(seller_id);
    }

    if (search) {
      whereConditions.push('(p.name LIKE ? OR p.description LIKE ?)');
      const searchTerm = `%${search}%`;
      queryParams.push(searchTerm, searchTerm);
    }

    const whereClause = whereConditions.length > 0 ? 'WHERE ' + whereConditions.join(' AND ') : '';
    
    // Get total count
    const [countResult] = await db.execute(`
      SELECT COUNT(*) as total 
      FROM products p
      ${whereClause}
    `, queryParams);

    const totalProducts = countResult[0].total;
    const offset = (page - 1) * limit;

    // Get products with seller info
    const [products] = await db.execute(`
      SELECT 
        p.id, p.name, p.description, p.price, p.status, p.created_at,
        p.category_id, p.stock_quantity,
        u.username as seller_name, u.email as seller_email,
        c.name as category_name
      FROM products p
      LEFT JOIN users u ON p.seller_id = u.id
      LEFT JOIN categories c ON p.category_id = c.id
      ${whereClause}
      ORDER BY p.${sort_by} ${sort_order}
      LIMIT ? OFFSET ?
    `, [...queryParams, parseInt(limit), offset]);

    res.json({
      success: true,
      message: 'Products retrieved successfully',
      products: products,
      pagination: {
        current_page: parseInt(page),
        per_page: parseInt(limit),
        total: totalProducts,
        total_pages: Math.ceil(totalProducts / limit)
      },
      filters: { status, category, seller_id, search }
    });
}));

// PUT /api/admin/products/:id/approve - Approve product
router.put('/products/:id/approve', enhancedErrorHandler(async (req, res) => {
    const { id } = req.params;
    const { notes } = req.body;

    await db.execute(`
      UPDATE products 
      SET status = 'active', updated_at = NOW()
      WHERE id = ?
    `, [id]);

    // Log the approval
    await db.execute(`
      INSERT INTO system_logs (level, message, details, created_at)
      VALUES (?, ?, ?, NOW())
    `, [
      'info',
      `Product approved`,
      JSON.stringify({
        product_id: id,
        notes: notes || 'No notes provided',
        approved_by: req.user.id,
        approved_by_email: req.user.email
      })
    ]);

    res.json({
      success: true,
      message: 'Product approved successfully'
    });
}));

// PUT /api/admin/products/:id/reject - Reject product
router.put('/products/:id/reject', enhancedErrorHandler(async (req, res) => {
    const { id } = req.params;
    const { reason } = req.body;

    if (!reason) {
      return res.status(400).json({
        success: false,
        message: 'Rejection reason is required'
      });
    }

    await db.execute(`
      UPDATE products 
      SET status = 'rejected', updated_at = NOW()
      WHERE id = ?
    `, [id]);

    // Log the rejection
    await db.execute(`
      INSERT INTO system_logs (level, message, details, created_at)
      VALUES (?, ?, ?, NOW())
    `, [
      'warning',
      `Product rejected`,
      JSON.stringify({
        product_id: id,
        reason: reason,
        rejected_by: req.user.id,
        rejected_by_email: req.user.email
      })
    ]);

    res.json({
      success: true,
      message: 'Product rejected successfully'
    });
}));

// ==================== ORDER MANAGEMENT ====================

// GET /api/admin/orders - Get all orders with filtering
router.get('/orders', enhancedErrorHandler(async (req, res) => {
    const { 
      status, 
      user_id,
      seller_id,
      search, 
      page = 1, 
      limit = 50,
      sort_by = 'created_at',
      sort_order = 'DESC'
    } = req.query;

    let whereConditions = [];
    let queryParams = [];

    if (status) {
      whereConditions.push('o.status = ?');
      queryParams.push(status);
    }

    if (user_id) {
      whereConditions.push('o.user_id = ?');
      queryParams.push(user_id);
    }

    if (seller_id) {
      whereConditions.push('o.seller_id = ?');
      queryParams.push(seller_id);
    }

    if (search) {
      whereConditions.push('(o.order_number LIKE ? OR u.email LIKE ?)');
      const searchTerm = `%${search}%`;
      queryParams.push(searchTerm, searchTerm);
    }

    const whereClause = whereConditions.length > 0 ? 'WHERE ' + whereConditions.join(' AND ') : '';
    
    // Get total count
    const [countResult] = await db.execute(`
      SELECT COUNT(*) as total 
      FROM orders o
      ${whereClause}
    `, queryParams);

    const totalOrders = countResult[0].total;
    const offset = (page - 1) * limit;

    // Get orders with user info
    const [orders] = await db.execute(`
      SELECT 
        o.id, o.order_number, o.total_amount, o.status, o.created_at,
        o.shipping_address, o.payment_method,
        u.username as buyer_name, u.email as buyer_email,
        s.username as seller_name, s.email as seller_email
      FROM orders o
      LEFT JOIN users u ON o.user_id = u.id
      LEFT JOIN users s ON o.seller_id = s.id
      ${whereClause}
      ORDER BY o.${sort_by} ${sort_order}
      LIMIT ? OFFSET ?
    `, [...queryParams, parseInt(limit), offset]);

    res.json({
      success: true,
      message: 'Orders retrieved successfully',
      orders: orders,
      pagination: {
        current_page: parseInt(page),
        per_page: parseInt(limit),
        total: totalOrders,
        total_pages: Math.ceil(totalOrders / limit)
      },
      filters: { status, user_id, seller_id, search }
    });
}));

// GET /api/admin/orders/:id - Get specific order details
router.get('/orders/:id', enhancedErrorHandler(async (req, res) => {
    const { id } = req.params;

    const [orders] = await db.execute(`
      SELECT 
        o.*, 
        u.username as buyer_name, u.email as buyer_email, u.phone as buyer_phone,
        s.username as seller_name, s.email as seller_email, s.phone as seller_phone
      FROM orders o
      LEFT JOIN users u ON o.user_id = u.id
      LEFT JOIN users s ON o.seller_id = s.id
      WHERE o.id = ?
    `, [id]);

    if (orders.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      });
    }

    // Get order items
    const [orderItems] = await db.execute(`
      SELECT 
        oi.*, 
        p.name as product_name
      FROM order_items oi
      LEFT JOIN products p ON oi.product_id = p.id
      WHERE oi.order_id = ?
    `, [id]);

    // Get payment transactions
    const [payments] = await db.execute(`
      SELECT * FROM payment_transactions 
      WHERE order_id = ?
      ORDER BY created_at DESC
    `, [id]);

    res.json({
      success: true,
      message: 'Order details retrieved successfully',
      order: orders[0],
      order_items: orderItems,
      payments: payments
    });
}));

// PUT /api/admin/orders/:id/status - Update order status
router.put('/orders/:id/status', enhancedErrorHandler(async (req, res) => {
    const { id } = req.params;
    const { status, reason } = req.body;

    const validStatuses = ['pending', 'processing', 'shipped', 'delivered', 'cancelled', 'refunded'];
    
    if (!validStatuses.includes(status)) {
      return res.status(400).json({
        success: false,
        message: `Invalid status. Must be one of: ${validStatuses.join(', ')}`
      });
    }

    // Get current order status
    const [currentOrder] = await db.execute('SELECT status FROM orders WHERE id = ?', [id]);
    
    if (currentOrder.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      });
    }

    const oldStatus = currentOrder[0].status;

    // Update order status
    await db.execute(`
      UPDATE orders 
      SET status = ?, updated_at = NOW()
      WHERE id = ?
    `, [status, id]);

    // Log status change in order_status_history if table exists
    try {
      await db.execute(`
        INSERT INTO order_status_history (order_id, old_status, new_status, changed_by, change_reason, created_at)
        VALUES (?, ?, ?, ?, ?, NOW())
      `, [id, oldStatus, status, req.user.id, reason || 'Status updated by admin']);
    } catch (error) {
      console.warn('order_status_history table not available:', error.message);
    }

    // Log the status change
    await db.execute(`
      INSERT INTO system_logs (level, message, details, created_at)
      VALUES (?, ?, ?, NOW())
    `, [
      'info',
      `Order status changed from ${oldStatus} to ${status}`,
      JSON.stringify({
        order_id: id,
        old_status: oldStatus,
        new_status: status,
        reason: reason || 'No reason provided',
        changed_by: req.user.id,
        changed_by_email: req.user.email
      })
    ]);

    res.json({
      success: true,
      message: `Order status updated to ${status} successfully`
    });
}));

// ==================== PAYMENT MANAGEMENT ====================

// GET /api/admin/pda-approvals/pending - Get pending payment approvals
router.get('/pda-approvals/pending', enhancedErrorHandler(async (req, res) => {
    try {
      // Try to get from admin_approvals table first
      const [approvals] = await db.execute(`
        SELECT 
          aa.id, aa.order_id, aa.approval_type, aa.status, aa.request_reason,
          aa.created_at, aa.updated_at,
          o.order_number, o.total_amount,
          u.username as buyer_name, u.email as buyer_email,
          s.username as seller_name, s.email as seller_email
        FROM admin_approvals aa
        LEFT JOIN orders o ON aa.order_id = o.id
        LEFT JOIN users u ON o.user_id = u.id
        LEFT JOIN users s ON o.seller_id = s.id
        WHERE aa.status = 'pending' AND aa.approval_type = 'MANUAL_PAYMENT'
        ORDER BY aa.created_at DESC
      `);

      res.json({
        success: true,
        message: 'Pending payment approvals retrieved successfully',
        approvals: approvals,
        count: approvals.length
      });

    } catch (error) {
      // Fallback to payment_transactions if admin_approvals doesn't exist
      console.warn('admin_approvals table not available, using payment_transactions fallback');
      
      const [transactions] = await db.execute(`
        SELECT 
          pt.id, pt.order_id, pt.amount, pt.status, pt.payment_method,
          pt.screenshot_url, pt.created_at,
          o.order_number, o.total_amount,
          u.username as buyer_name, u.email as buyer_email,
          s.username as seller_name, s.email as seller_email
        FROM payment_transactions pt
        LEFT JOIN orders o ON pt.order_id = o.id
        LEFT JOIN users u ON o.user_id = u.id
        LEFT JOIN users s ON o.seller_id = s.id
        WHERE pt.status = 'pending_confirmation'
        ORDER BY pt.created_at DESC
      `);

      // Transform to match expected format
      const approvals = transactions.map(t => ({
        id: t.id,
        order_id: t.order_id,
        approval_type: 'MANUAL_PAYMENT',
        status: 'pending',
        request_reason: `Payment confirmation needed for ${t.payment_method} payment`,
        created_at: t.created_at,
        updated_at: t.created_at,
        order_number: t.order_number,
        total_amount: t.total_amount,
        buyer_name: t.buyer_name,
        buyer_email: t.buyer_email,
        seller_name: t.seller_name,
        seller_email: t.seller_email,
        amount: t.amount,
        payment_method: t.payment_method,
        screenshot_url: t.screenshot_url
      }));

      res.json({
        success: true,
        message: 'Pending payment approvals retrieved successfully (from transactions)',
        approvals: approvals,
        count: approvals.length
      });
    }
}));

// POST /api/admin/pda-approvals/:id/approve - Approve payment
router.post('/pda-approvals/:id/approve', enhancedErrorHandler(async (req, res) => {
    const { id } = req.params;
    const { notes } = req.body;

    try {
      // Try admin_approvals table first
      await db.execute(`
        UPDATE admin_approvals 
        SET status = 'approved', reviewed_by = ?, review_notes = ?, approved_at = NOW(), updated_at = NOW()
        WHERE id = ? AND status = 'pending'
      `, [req.user.id, notes || 'Approved by admin', id]);

      // Also update the related payment transaction
      const [approval] = await db.execute('SELECT order_id FROM admin_approvals WHERE id = ?', [id]);
      
      if (approval.length > 0) {
        await db.execute(`
          UPDATE payment_transactions 
          SET status = 'completed', processed_by = ?, processed_at = NOW(), admin_notes = ?
          WHERE order_id = ?
        `, [req.user.id, notes || 'Approved by admin', approval[0].order_id]);

        // Update order payment status
        await db.execute(`
          UPDATE orders 
          SET manual_payment_approved = TRUE, manual_payment_approved_by = ?, manual_payment_approved_at = NOW()
          WHERE id = ?
        `, [req.user.id, approval[0].order_id]);
      }

    } catch (error) {
      // Fallback to payment_transactions table
      console.warn('Using payment_transactions fallback for approval');
      
      await db.execute(`
        UPDATE payment_transactions 
        SET status = 'completed', processed_by = ?, processed_at = NOW(), admin_notes = ?
        WHERE id = ? AND status = 'pending_confirmation'
      `, [req.user.id, notes || 'Approved by admin', id]);

      // Get order_id and update order
      const [transaction] = await db.execute('SELECT order_id FROM payment_transactions WHERE id = ?', [id]);
      
      if (transaction.length > 0) {
        await db.execute(`
          UPDATE orders 
          SET manual_payment_approved = TRUE, manual_payment_approved_by = ?, manual_payment_approved_at = NOW()
          WHERE id = ?
        `, [req.user.id, transaction[0].order_id]);
      }
    }

    // Log the approval
    await db.execute(`
      INSERT INTO system_logs (level, message, details, created_at)
      VALUES (?, ?, ?, NOW())
    `, [
      'info',
      `Payment approval granted`,
      JSON.stringify({
        approval_id: id,
        notes: notes || 'No notes provided',
        approved_by: req.user.id,
        approved_by_email: req.user.email
      })
    ]);

    res.json({
      success: true,
      message: 'Payment approved successfully'
    });
}));

// POST /api/admin/pda-approvals/:id/reject - Reject payment
router.post('/pda-approvals/:id/reject', enhancedErrorHandler(async (req, res) => {
    const { id } = req.params;
    const { reason } = req.body;

    if (!reason) {
      return res.status(400).json({
        success: false,
        message: 'Rejection reason is required'
      });
    }

    try {
      // Try admin_approvals table first
      await db.execute(`
        UPDATE admin_approvals 
        SET status = 'rejected', reviewed_by = ?, review_notes = ?, rejected_at = NOW(), updated_at = NOW()
        WHERE id = ? AND status = 'pending'
      `, [req.user.id, reason, id]);

      // Also update the related payment transaction
      const [approval] = await db.execute('SELECT order_id FROM admin_approvals WHERE id = ?', [id]);
      
      if (approval.length > 0) {
        await db.execute(`
          UPDATE payment_transactions 
          SET status = 'rejected', processed_by = ?, processed_at = NOW(), admin_notes = ?
          WHERE order_id = ?
        `, [req.user.id, reason, approval[0].order_id]);
      }

    } catch (error) {
      // Fallback to payment_transactions table
      console.warn('Using payment_transactions fallback for rejection');
      
      await db.execute(`
        UPDATE payment_transactions 
        SET status = 'rejected', processed_by = ?, processed_at = NOW(), admin_notes = ?
        WHERE id = ? AND status = 'pending_confirmation'
      `, [req.user.id, reason, id]);
    }

    // Log the rejection
    await db.execute(`
      INSERT INTO system_logs (level, message, details, created_at)
      VALUES (?, ?, ?, NOW())
    `, [
      'warning',
      `Payment approval rejected`,
      JSON.stringify({
        approval_id: id,
        reason: reason,
        rejected_by: req.user.id,
        rejected_by_email: req.user.email
      })
    ]);

    res.json({
      success: true,
      message: 'Payment rejected successfully'
    });
}));

// ==================== AGENT MANAGEMENT ====================

// GET /api/admin/agents - Get all agents
router.get('/agents', enhancedErrorHandler(async (req, res) => {
    const { status, page = 1, limit = 50 } = req.query;

    let whereConditions = ["role = 'agent'"];
    let queryParams = [];

    if (status) {
      if (status === 'active') {
        whereConditions.push('is_active = 1');
      } else if (status === 'inactive') {
        whereConditions.push('is_active = 0');
      }
    }

    const whereClause = 'WHERE ' + whereConditions.join(' AND ');
    const offset = (page - 1) * limit;

    // Get agents
    const [agents] = await db.execute(`
      SELECT 
        id, username, email, first_name, last_name, phone,
        is_active, is_verified, created_at
      FROM users 
      ${whereClause}
      ORDER BY created_at DESC
      LIMIT ? OFFSET ?
    `, [...queryParams, parseInt(limit), offset]);

    // Get total count
    const [countResult] = await db.execute(`
      SELECT COUNT(*) as total 
      FROM users 
      ${whereClause}
    `, queryParams);

    res.json({
      success: true,
      message: 'Agents retrieved successfully',
      agents: agents,
      pagination: {
        current_page: parseInt(page),
        per_page: parseInt(limit),
        total: countResult[0].total,
        total_pages: Math.ceil(countResult[0].total / limit)
      }
    });
}));

// ==================== SYSTEM MANAGEMENT ====================

// GET /api/admin/activities - Get recent system activities
router.get('/activities', enhancedErrorHandler(async (req, res) => {
    const { limit = 50 } = req.query;

    const [activities] = await db.execute(`
      SELECT level, message, details, created_at
      FROM system_logs 
      ORDER BY created_at DESC 
      LIMIT ?
    `, [parseInt(limit)]);

    res.json({
      success: true,
      message: 'System activities retrieved successfully',
      activities: activities
    });
}));

// POST /api/admin/error-reports - Receive error reports from frontend
router.post('/error-reports', enhancedErrorHandler(async (req, res) => {
    const errorData = req.body;

    try {
      await db.execute(`
        INSERT INTO error_reports (
          error_id, error_type, message, stack_trace, url, 
          user_id, user_agent, ip_address, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW())
      `, [
        errorData.id || 'unknown',
        errorData.type || 'frontend_error',
        errorData.message || 'No message',
        errorData.stack || null,
        errorData.page || req.headers.referer,
        req.user?.id || null,
        req.headers['user-agent'],
        req.ip
      ]);
    } catch (error) {
      // If error_reports table doesn't exist, log to system_logs
      await db.execute(`
        INSERT INTO system_logs (level, message, details, created_at)
        VALUES (?, ?, ?, NOW())
      `, [
        'error',
        'Frontend Error Report',
        JSON.stringify(errorData)
      ]);
    }

    res.json({
      success: true,
      message: 'Error report received'
    });
}));

// ==================== PRODUCT MANAGEMENT ====================

// GET /api/admin/products - Get all products with admin filtering
router.get('/products', enhancedErrorHandler(async (req, res) => {
    const { 
      status, 
      category_id, 
      seller_id,
      search, 
      page = 1, 
      limit = 50,
      sort_by = 'created_at',
      sort_order = 'DESC'
    } = req.query;

    let whereConditions = [];
    let queryParams = [];

    // Build dynamic WHERE clause
    if (status) {
      if (status === 'active') {
        whereConditions.push('p.status IN (?, ?)');
        queryParams.push('active', 'approved');
      } else {
        whereConditions.push('p.status = ?');
        queryParams.push(status);
      }
    }

    if (category_id) {
      whereConditions.push('p.category_id = ?');
      queryParams.push(category_id);
    }

    if (seller_id) {
      whereConditions.push('p.seller_id = ?');
      queryParams.push(seller_id);
    }

    if (search) {
      whereConditions.push('(p.name LIKE ? OR p.description LIKE ? OR u.username LIKE ?)');
      const searchTerm = `%${search}%`;
      queryParams.push(searchTerm, searchTerm, searchTerm);
    }

    const whereClause = whereConditions.length > 0 ? 'WHERE ' + whereConditions.join(' AND ') : '';
    
    // Get total count
    const [countResult] = await db.execute(`
      SELECT COUNT(*) as total 
      FROM products p
      LEFT JOIN users u ON p.seller_id = u.id
      ${whereClause}
    `, queryParams);

    const totalProducts = countResult[0].total;
    const offset = (page - 1) * limit;

    // Get products with seller info
    const [products] = await db.execute(`
      SELECT 
        p.id, p.name, p.description, p.price, p.status, p.main_image,
        p.created_at, p.updated_at, p.category_id,
        u.username as seller_name, u.email as seller_email,
        c.name as category_name
      FROM products p
      LEFT JOIN users u ON p.seller_id = u.id
      LEFT JOIN categories c ON p.category_id = c.id
      ${whereClause}
      ORDER BY p.${sort_by} ${sort_order}
      LIMIT ? OFFSET ?
    `, [...queryParams, parseInt(limit), offset]);

    // Get product statistics
    let productStats = [{ 
      total_products: 0, 
      active_products: 0, 
      pending_products: 0, 
      rejected_products: 0, 
      inactive_products: 0 
    }];
    
    try {
      const [stats] = await db.execute(`
        SELECT 
          COUNT(*) as total_products,
          COUNT(CASE WHEN status IN ('active', 'approved') THEN 1 END) as active_products,
          COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_products,
          COUNT(CASE WHEN status = 'rejected' THEN 1 END) as rejected_products,
          COUNT(CASE WHEN status = 'inactive' THEN 1 END) as inactive_products
        FROM products
      `);
      productStats = stats;
    } catch (statsError) {
      console.error('Error getting product statistics:', statsError);
    }

    res.json({
      success: true,
      message: 'Products retrieved successfully',
      products: products,
      pagination: {
        current_page: parseInt(page),
        per_page: parseInt(limit),
        total: totalProducts,
        total_pages: Math.ceil(totalProducts / limit)
      },
      statistics: productStats[0],
      filters: { status, category_id, seller_id, search }
    });
}));

// GET /api/admin/products/:id - Get specific product details
router.get('/products/:id', enhancedErrorHandler(async (req, res) => {
    const { id } = req.params;

    const [products] = await db.execute(`
      SELECT 
        p.*, 
        u.username as seller_name, u.email as seller_email, u.phone as seller_phone,
        c.name as category_name
      FROM products p
      LEFT JOIN users u ON p.seller_id = u.id
      LEFT JOIN categories c ON p.category_id = c.id
      WHERE p.id = ?
    `, [id]);

    if (products.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Product not found'
      });
    }

    const product = products[0];

    // Get product images
    const [images] = await db.execute(`
      SELECT image_url, is_main 
      FROM product_images 
      WHERE product_id = ?
      ORDER BY is_main DESC, created_at ASC
    `, [id]);

    res.json({
      success: true,
      message: 'Product details retrieved successfully',
      product: {
        ...product,
        images: images
      }
    });
}));

// PUT /api/admin/products/:id/status - Update product status (approve/reject)
router.put('/products/:id/status', enhancedErrorHandler(async (req, res) => {
    const { id } = req.params;
    const { status, reason } = req.body;

    if (!['active', 'pending', 'rejected', 'inactive'].includes(status)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid status. Must be active, pending, rejected, or inactive'
      });
    }

    // Get product details for logging
    const [products] = await db.execute('SELECT * FROM products WHERE id = ?', [id]);
    if (products.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Product not found'
      });
    }

    const product = products[0];

    // Update product status
    await db.execute(`
      UPDATE products 
      SET status = ?, updated_at = NOW()
      WHERE id = ?
    `, [status, id]);

    // Log the status change
    await db.execute(`
      INSERT INTO system_logs (level, message, details, created_at)
      VALUES (?, ?, ?, NOW())
    `, [
      'info',
      `Product status updated by admin`,
      JSON.stringify({
        product_id: id,
        product_name: product.name,
        old_status: product.status,
        new_status: status,
        reason: reason || 'No reason provided',
        admin_email: req.user?.email || 'unknown',
        timestamp: new Date().toISOString()
      })
    ]);

    // Send notification to seller if status changed to rejected
    if (status === 'rejected' && product.seller_id) {
      try {
        const [sellers] = await db.execute('SELECT email, first_name FROM users WHERE id = ?', [product.seller_id]);
        if (sellers.length > 0) {
          await sendTemplatedEmail(
            sellers[0].email,
            'Product Rejected',
            'product-rejected',
            {
              sellerName: sellers[0].first_name,
              productName: product.name,
              reason: reason || 'Please review product details and resubmit',
              supportEmail: process.env.SUPPORT_EMAIL || 'support@addphysicalproducts.com'
            }
          );
        }
      } catch (emailError) {
        console.error('Failed to send rejection email:', emailError);
      }
    }

    res.json({
      success: true,
      message: `Product status updated to ${status}`,
      product_id: id,
      new_status: status
    });
}));

// DELETE /api/admin/products/:id - Delete product (soft delete)
router.delete('/products/:id', enhancedErrorHandler(async (req, res) => {
    const { id } = req.params;
    const { reason } = req.body;

    // Get product details for logging
    const [products] = await db.execute('SELECT * FROM products WHERE id = ?', [id]);
    if (products.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Product not found'
      });
    }

    const product = products[0];

    // Soft delete the product
    await db.execute(`
      UPDATE products 
      SET status = 'deleted', updated_at = NOW()
      WHERE id = ?
    `, [id]);

    // Log the deletion
    await db.execute(`
      INSERT INTO system_logs (level, message, details, created_at)
      VALUES (?, ?, ?, NOW())
    `, [
      'warning',
      `Product deleted by admin`,
      JSON.stringify({
        product_id: id,
        product_name: product.name,
        seller_id: product.seller_id,
        reason: reason || 'No reason provided',
        admin_email: req.user?.email || 'unknown',
        timestamp: new Date().toISOString()
      })
    ]);

    res.json({
      success: true,
      message: 'Product deleted successfully',
      product_id: id
    });
}));

// ==================== ORDER MANAGEMENT ====================

// GET /api/admin/orders - Get all orders with admin filtering
router.get('/orders', enhancedErrorHandler(async (req, res) => {
    const { 
      status, 
      user_id,
      agent_id,
      search, 
      page = 1, 
      limit = 50,
      sort_by = 'created_at',
      sort_order = 'DESC'
    } = req.query;

    let whereConditions = [];
    let queryParams = [];

    // Build dynamic WHERE clause
    if (status) {
      whereConditions.push('o.status = ?');
      queryParams.push(status);
    }

    if (user_id) {
      whereConditions.push('o.user_id = ?');
      queryParams.push(user_id);
    }

    if (agent_id) {
      whereConditions.push('o.agent_id = ?');
      queryParams.push(agent_id);
    }

    if (search) {
      whereConditions.push('(o.order_number LIKE ? OR u.username LIKE ? OR u.email LIKE ?)');
      const searchTerm = `%${search}%`;
      queryParams.push(searchTerm, searchTerm, searchTerm);
    }

    const whereClause = whereConditions.length > 0 ? 'WHERE ' + whereConditions.join(' AND ') : '';
    
    // Get total count
    const [countResult] = await db.execute(`
      SELECT COUNT(*) as total 
      FROM orders o
      LEFT JOIN users u ON o.user_id = u.id
      ${whereClause}
    `, queryParams);

    const totalOrders = countResult[0].total;
    const offset = (page - 1) * limit;

    // Get orders with user and agent info
    const [orders] = await db.execute(`
      SELECT 
        o.id, o.order_number, o.total_amount, o.status, o.created_at, o.updated_at,
        u.username as buyer_name, u.email as buyer_email,
        a.username as agent_name, a.email as agent_email
      FROM orders o
      LEFT JOIN users u ON o.user_id = u.id
      LEFT JOIN users a ON o.agent_id = a.id
      ${whereClause}
      ORDER BY o.${sort_by} ${sort_order}
      LIMIT ? OFFSET ?
    `, [...queryParams, parseInt(limit), offset]);

    // Get order statistics
    const [orderStats] = await db.execute(`
      SELECT 
        COUNT(*) as total_orders,
        COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_orders,
        COUNT(CASE WHEN status = 'processing' THEN 1 END) as processing_orders,
        COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_orders,
        COUNT(CASE WHEN status = 'cancelled' THEN 1 END) as cancelled_orders,
        COALESCE(SUM(total_amount), 0) as total_revenue
      FROM orders
    `);

    res.json({
      success: true,
      message: 'Orders retrieved successfully',
      orders: orders,
      pagination: {
        current_page: parseInt(page),
        per_page: parseInt(limit),
        total: totalOrders,
        total_pages: Math.ceil(totalOrders / limit)
      },
      statistics: orderStats[0],
      filters: { status, user_id, agent_id, search }
    });
}));

// GET /api/admin/orders/:id - Get specific order details
router.get('/orders/:id', enhancedErrorHandler(async (req, res) => {
    const { id } = req.params;

    const [orders] = await db.execute(`
      SELECT 
        o.*, 
        u.username as buyer_name, u.email as buyer_email, u.phone as buyer_phone,
        a.username as agent_name, a.email as agent_email, a.phone as agent_phone
      FROM orders o
      LEFT JOIN users u ON o.user_id = u.id
      LEFT JOIN users a ON o.agent_id = a.id
      WHERE o.id = ?
    `, [id]);

    if (orders.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      });
    }

    const order = orders[0];

    // Get order items
    const [orderItems] = await db.execute(`
      SELECT 
        oi.*, 
        p.name as product_name, p.main_image as product_image,
        u.username as seller_name, u.email as seller_email
      FROM order_items oi
      LEFT JOIN products p ON oi.product_id = p.id
      LEFT JOIN users u ON p.seller_id = u.id
      WHERE oi.order_id = ?
    `, [id]);

    res.json({
      success: true,
      message: 'Order details retrieved successfully',
      order: {
        ...order,
        items: orderItems
      }
    });
}));

// PUT /api/admin/orders/:id/status - Update order status
router.put('/orders/:id/status', enhancedErrorHandler(async (req, res) => {
    const { id } = req.params;
    const { status, reason } = req.body;

    if (!['pending', 'processing', 'shipped', 'delivered', 'completed', 'cancelled'].includes(status)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid status'
      });
    }

    // Get order details for logging
    const [orders] = await db.execute('SELECT * FROM orders WHERE id = ?', [id]);
    if (orders.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      });
    }

    const order = orders[0];

    // Update order status
    await db.execute(`
      UPDATE orders 
      SET status = ?, updated_at = NOW()
      WHERE id = ?
    `, [status, id]);

    // Log the status change
    await db.execute(`
      INSERT INTO system_logs (level, message, details, created_at)
      VALUES (?, ?, ?, NOW())
    `, [
      'info',
      `Order status updated by admin`,
      JSON.stringify({
        order_id: id,
        order_number: order.order_number,
        old_status: order.status,
        new_status: status,
        reason: reason || 'No reason provided',
        admin_email: req.user?.email || 'unknown',
        timestamp: new Date().toISOString()
      })
    ]);

    res.json({
      success: true,
      message: `Order status updated to ${status}`,
      order_id: id,
      new_status: status
    });
}));

// ==================== HEALTH CHECK ====================

// GET /api/admin/health - Health check endpoint
router.get('/health', (req, res) => {
    res.json({
      success: true,
      message: 'Admin API is healthy',
      timestamp: new Date().toISOString(),
      version: '1.0.0'
    });
});


// ==================== ADDITIONAL ADMIN ENDPOINTS ====================

// GET /api/admin/agents - Get all agents
router.get('/agents', enhancedErrorHandler(async (req, res) => {
    const { page = 1, limit = 50, status, search } = req.query;
    
    let whereConditions = [];
    let queryParams = [];
    
    if (status) {
        whereConditions.push('status = ?');
        queryParams.push(status);
    }
    
    if (search) {
        whereConditions.push('(name LIKE ? OR email LIKE ? OR phone LIKE ?)');
        const searchTerm = `%${search}%`;
        queryParams.push(searchTerm, searchTerm, searchTerm);
    }
    
    const whereClause = whereConditions.length > 0 ? 'WHERE ' + whereConditions.join(' AND ') : '';
    
    const [agents] = await db.execute(`
        SELECT id, name, email, phone, status, agent_type, location, created_at
        FROM agents 
        ${whereClause}
        ORDER BY created_at DESC
        LIMIT ? OFFSET ?
    `, [...queryParams, parseInt(limit), (page - 1) * limit]);
    
    const [countResult] = await db.execute(`
        SELECT COUNT(*) as total FROM agents ${whereClause}
    `, queryParams);
    
    res.json({
        success: true,
        message: 'Agents retrieved successfully',
        agents,
        pagination: {
            current_page: parseInt(page),
            per_page: parseInt(limit),
            total: countResult[0].total,
            total_pages: Math.ceil(countResult[0].total / limit)
        }
    });
}));

// POST /api/admin/agents/:id/approve - Approve agent
router.post('/agents/:id/approve', enhancedErrorHandler(async (req, res) => {
    const { id } = req.params;
    const { reason } = req.body;
    
    await db.execute(`
        UPDATE agents 
        SET status = 'approved', approved_by = ?, approved_at = NOW(), approval_reason = ?
        WHERE id = ?
    `, [req.user.id, reason || 'Approved by admin', id]);
    
    res.json({
        success: true,
        message: 'Agent approved successfully'
    });
}));

// POST /api/admin/agents/:id/reject - Reject agent
router.post('/agents/:id/reject', enhancedErrorHandler(async (req, res) => {
    const { id } = req.params;
    const { reason } = req.body;
    
    await db.execute(`
        UPDATE agents 
        SET status = 'rejected', rejected_by = ?, rejected_at = NOW(), rejection_reason = ?
        WHERE id = ?
    `, [req.user.id, reason || 'Rejected by admin', id]);
    
    res.json({
        success: true,
        message: 'Agent rejected successfully'
    });
}));

// GET /api/admin/announcements - Get all announcements
router.get('/announcements', enhancedErrorHandler(async (req, res) => {
    const [announcements] = await db.execute(`
        SELECT id, title, content, type, status, created_at, updated_at
        FROM announcements 
        ORDER BY created_at DESC
    `);
    
    res.json({
        success: true,
        message: 'Announcements retrieved successfully',
        announcements
    });
}));

// POST /api/admin/announcements - Create announcement
router.post('/announcements', enhancedErrorHandler(async (req, res) => {
    const { title, content, type = 'general', status = 'draft' } = req.body;
    
    const [result] = await db.execute(`
        INSERT INTO announcements (title, content, type, status, created_by, created_at)
        VALUES (?, ?, ?, ?, ?, NOW())
    `, [title, content, type, status, req.user.id]);
    
    res.json({
        success: true,
        message: 'Announcement created successfully',
        id: result.insertId
    });
}));

// GET /api/admin/brands - Get all brands
router.get('/brands', enhancedErrorHandler(async (req, res) => {
    const [brands] = await db.execute(`
        SELECT id, name, description, logo_url, status, created_at
        FROM brands 
        ORDER BY name ASC
    `);
    
    res.json({
        success: true,
        message: 'Brands retrieved successfully',
        brands
    });
}));

// POST /api/admin/brands - Create brand
router.post('/brands', enhancedErrorHandler(async (req, res) => {
    const { name, description, logo_url, status = 'active' } = req.body;
    
    const [result] = await db.execute(`
        INSERT INTO brands (name, description, logo_url, status, created_at)
        VALUES (?, ?, ?, ?, NOW())
    `, [name, description, logo_url, status]);
    
    res.json({
        success: true,
        message: 'Brand created successfully',
        id: result.insertId
    });
}));

// GET /api/admin/categories - Get all categories
router.get('/categories', enhancedErrorHandler(async (req, res) => {
    const [categories] = await db.execute(`
        SELECT id, name, description, parent_id, status, created_at
        FROM categories 
        ORDER BY parent_id ASC, name ASC
    `);
    
    res.json({
        success: true,
        message: 'Categories retrieved successfully',
        categories
    });
}));

// GET /api/admin/reviews - Get all reviews
router.get('/reviews', enhancedErrorHandler(async (req, res) => {
    const { status, page = 1, limit = 50 } = req.query;
    
    let whereClause = '';
    let queryParams = [];
    
    if (status) {
        whereClause = 'WHERE r.status = ?';
        queryParams.push(status);
    }
    
    const [reviews] = await db.execute(`
        SELECT r.*, p.name as product_name, u.username as reviewer_name
        FROM reviews r
        LEFT JOIN products p ON r.product_id = p.id
        LEFT JOIN users u ON r.user_id = u.id
        ${whereClause}
        ORDER BY r.created_at DESC
        LIMIT ? OFFSET ?
    `, [...queryParams, parseInt(limit), (page - 1) * limit]);
    
    res.json({
        success: true,
        message: 'Reviews retrieved successfully',
        reviews
    });
}));

// POST /api/admin/reviews/:id/approve - Approve review
router.post('/reviews/:id/approve', enhancedErrorHandler(async (req, res) => {
    const { id } = req.params;
    
    await db.execute(`
        UPDATE reviews 
        SET status = 'approved', approved_by = ?, approved_at = NOW()
        WHERE id = ?
    `, [req.user.id, id]);
    
    res.json({
        success: true,
        message: 'Review approved successfully'
    });
}));

// GET /api/admin/sellers - Get all sellers
router.get('/sellers', enhancedErrorHandler(async (req, res) => {
    const { status, page = 1, limit = 50 } = req.query;
    
    let whereClause = 'WHERE u.role = "seller"';
    let queryParams = [];
    
    if (status) {
        whereClause += ' AND u.is_active = ?';
        queryParams.push(status === 'active' ? 1 : 0);
    }
    
    const [sellers] = await db.execute(`
        SELECT u.id, u.username, u.email, u.first_name, u.last_name, 
               u.is_active, u.is_verified, u.created_at,
               COUNT(p.id) as total_products
        FROM users u
        LEFT JOIN products p ON u.id = p.seller_id
        ${whereClause}
        GROUP BY u.id
        ORDER BY u.created_at DESC
        LIMIT ? OFFSET ?
    `, [...queryParams, parseInt(limit), (page - 1) * limit]);
    
    res.json({
        success: true,
        message: 'Sellers retrieved successfully',
        sellers
    });
}));

// GET /api/admin/support-tickets - Get all support tickets
router.get('/support-tickets', enhancedErrorHandler(async (req, res) => {
    const { status, priority, page = 1, limit = 50 } = req.query;
    
    let whereConditions = [];
    let queryParams = [];
    
    if (status) {
        whereConditions.push('status = ?');
        queryParams.push(status);
    }
    
    if (priority) {
        whereConditions.push('priority = ?');
        queryParams.push(priority);
    }
    
    const whereClause = whereConditions.length > 0 ? 'WHERE ' + whereConditions.join(' AND ') : '';
    
    const [tickets] = await db.execute(`
        SELECT t.*, u.username as user_name
        FROM support_tickets t
        LEFT JOIN users u ON t.user_id = u.id
        ${whereClause}
        ORDER BY t.created_at DESC
        LIMIT ? OFFSET ?
    `, [...queryParams, parseInt(limit), (page - 1) * limit]);
    
    res.json({
        success: true,
        message: 'Support tickets retrieved successfully',
        tickets
    });
}));

// GET /api/admin/system-logs - Get system logs
router.get('/system-logs', enhancedErrorHandler(async (req, res) => {
    const { level, page = 1, limit = 100 } = req.query;
    
    let whereClause = '';
    let queryParams = [];
    
    if (level) {
        whereClause = 'WHERE level = ?';
        queryParams.push(level);
    }
    
    const [logs] = await db.execute(`
        SELECT * FROM system_logs 
        ${whereClause}
        ORDER BY created_at DESC
        LIMIT ? OFFSET ?
    `, [...queryParams, parseInt(limit), (page - 1) * limit]);
    
    res.json({
        success: true,
        message: 'System logs retrieved successfully',
        logs
    });
}));

// GET /api/admin/promotions - Get all promotions
router.get('/promotions', enhancedErrorHandler(async (req, res) => {
    const [promotions] = await db.execute(`
        SELECT * FROM promotions 
        ORDER BY created_at DESC
    `);
    
    res.json({
        success: true,
        message: 'Promotions retrieved successfully',
        promotions
    });
}));

// GET /api/admin/health-check - System health check
router.get('/health-check', enhancedErrorHandler(async (req, res) => {
    const healthStatus = {
        database: 'healthy',
        server: 'healthy',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        memory: process.memoryUsage()
    };
    
    try {
        // Test database connection
        await db.execute('SELECT 1');
        healthStatus.database = 'healthy';
    } catch (error) {
        healthStatus.database = 'unhealthy';
        healthStatus.database_error = error.message;
    }
    
    res.json({
        success: true,
        message: 'Health check completed',
        health: healthStatus
    });
}));


module.exports = router;