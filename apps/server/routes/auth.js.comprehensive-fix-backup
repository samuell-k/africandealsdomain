const express = require('express');
const router = express.Router();
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const pool = require('../db');
const { sendTemplatedEmail } = require('../utils/mailer');
   
// Register (all roles)
router.post('/register', async (req, res, next) => {
  try {
    console.log('[AUTH DEBUG] Registration attempt:', { email: req.body.email, role: req.body.role });
    
    const { name, email, password, role, phone } = req.body;
    
    // Enhanced validation
    if (!name || !email || !password || !role) {
      console.log('[AUTH ERROR] Missing required fields');
      return res.status(400).json({ error: 'All fields are required' });
    }
    
    if (!['buyer','seller','agent','admin'].includes(role)) {
      console.log('[AUTH ERROR] Invalid role:', role);
      return res.status(400).json({ error: 'Invalid role' });
    }
    
    if (!/^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(email)) {
      console.log('[AUTH ERROR] Invalid email format:', email);
      return res.status(400).json({ error: 'Invalid email format' });
    }
    
    if (password.length < 6) {
      console.log('[AUTH ERROR] Password too short');
      return res.status(400).json({ error: 'Password must be at least 6 characters' });
    }
    
    try {
      const [existing] = await pool.query('SELECT id, role FROM users WHERE email = ?', [email]);
      if (existing.length > 0) {
        console.log('[AUTH ERROR] Email already registered:', email);
        return res.status(409).json({ error: 'Email already registered' });
      }
    } catch (dbErr) {
      console.error('[DB ERROR] Check existing user failed:', dbErr.message);
      if (dbErr.message.includes('ER_NO_SUCH_TABLE')) {
        console.error("[DB ERROR] 'users' table missing. Attempting to create...");
        try {
          await pool.query(`CREATE TABLE IF NOT EXISTS users (
            id INT AUTO_INCREMENT PRIMARY KEY,
            name VARCHAR(255),
            email VARCHAR(255) UNIQUE,
            password VARCHAR(255),
            role VARCHAR(32),
            phone VARCHAR(32),
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          )`);
          console.log("[DB FIX] 'users' table created.");
        } catch (createErr) {
          console.error('[DB ERROR] Failed to create users table:', createErr.message);
          return res.status(500).json({ error: 'Database error: users table missing and could not be created.' });
        }
      } else {
        return res.status(500).json({ error: 'Database error: ' + dbErr.message });
      }
    }
    
    const hash = await bcrypt.hash(password, 10);
    console.log('[AUTH DEBUG] Password hashed successfully');
    
    try {
      const [result] = await pool.query(
        'INSERT INTO users (name, email, password, role, phone) VALUES (?, ?, ?, ?, ?)',
        [name, email, hash, role, phone || null]
      );
      
      const user = { id: result.insertId, name, email, role, phone };
      
      // If registering as agent, create agent profile
      if (role === 'agent') {
        try {
          await pool.query(`
            INSERT INTO agents (user_id, first_name, last_name, email, phone, status, agent_type, created_at)
            VALUES (?, ?, ?, ?, ?, 'offline', NULL, NOW())
            ON DUPLICATE KEY UPDATE
            first_name = VALUES(first_name),
            last_name = VALUES(last_name),
            email = VALUES(email),
            phone = VALUES(phone)
          `, [
            user.id,
            req.body.first_name || name.split(' ')[0] || '',
            req.body.last_name || name.split(' ')[1] || '',
            email,
            phone
          ]);
          console.log('[AUTH SUCCESS] Agent profile created for user:', user.id);
        } catch (agentErr) {
          console.error('[AUTH WARNING] Failed to create agent profile:', agentErr.message);
          // Don't fail registration if agent profile creation fails
        }
      }
      
      const token = jwt.sign(
        { id: user.id, role: user.role, name: user.name }, 
        process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-this-in-production', 
        { expiresIn: '7d' }
      );
      
      // Send welcome email
      try {
        const dashboardUrls = {
          buyer: 'https://africandealsdomain.com/buyer/dashboard',
          seller: 'https://africandealsdomain.com/seller/dashboard',
          agent: 'https://africandealsdomain.com/agent/dashboard',
          admin: 'https://africandealsdomain.com/admin/dashboard'
        };
        
        await sendTemplatedEmail(
          email,
          `Welcome to African Deals Domain, ${name}!`,
          'welcome',
          {
            userName: name,
            userType: role.charAt(0).toUpperCase() + role.slice(1),
            email: email,
            dashboardUrl: dashboardUrls[role] || 'https://africandealsdomain.com',
            websiteUrl: 'https://africandealsdomain.com',
            supportUrl: 'https://africandealsdomain.com/support',
            contactUrl: 'https://africandealsdomain.com/contact'
          }
        );
        console.log('[EMAIL SUCCESS] Welcome email sent to:', email);
      } catch (emailErr) {
        console.error('[EMAIL ERROR] Failed to send welcome email:', emailErr.message);
        // Don't fail registration if email fails
      }
      
      // Send admin alert for new agent/seller registrations
      if (role === 'agent' || role === 'seller') {
        try {
          await sendTemplatedEmail(
            'admin@africandealsdomain.com',
            `New ${role.charAt(0).toUpperCase() + role.slice(1)} Registration - ${name}`,
            'admin-alert',
            {
              alertType: 'Registration',
              alertTitle: `New ${role.charAt(0).toUpperCase() + role.slice(1)} Registration`,
              alertDescription: `A new ${role} has registered on the platform and may require verification.`,
              priority: 'medium',
              timestamp: new Date().toLocaleString(),
              alertId: `REG-${Date.now()}`,
              systemModule: 'User Registration',
              eventType: `${role.charAt(0).toUpperCase() + role.slice(1)} Registration`,
              severityLevel: 'Medium',
              userInfo: {
                userName: name,
                userEmail: email,
                userType: role.charAt(0).toUpperCase() + role.slice(1),
                userId: user.id,
                registrationDate: new Date().toLocaleDateString(),
                userPhone: phone || 'Not provided'
              },
              recommendedActions: [
                `Review the new ${role} profile`,
                'Verify contact information',
                'Send welcome message if appropriate',
                'Monitor initial activity'
              ],
              adminDashboardUrl: 'https://africandealsdomain.com/admin/dashboard',
              reviewUrl: `https://africandealsdomain.com/admin/users/${user.id}`,
              systemLogsUrl: 'https://africandealsdomain.com/admin/logs',
              supportUrl: 'https://africandealsdomain.com/admin/support'
            }
          );
          console.log('[EMAIL SUCCESS] Admin alert sent for new', role);
        } catch (emailErr) {
          console.error('[EMAIL ERROR] Failed to send admin alert:', emailErr.message);
        }
      } 
      
      console.log('[AUTH SUCCESS] User registered:', { id: user.id, email: user.email, role: user.role });
      return res.json({ token, user });
      
    } catch (dbErr) {
      console.error('[DB ERROR] Insert user failed:', dbErr.message);
      if (dbErr.message.includes('ER_NO_SUCH_TABLE')) {
        return res.status(500).json({ error: 'Database error: users table missing.' });
      }
      if (dbErr.message.includes('ER_BAD_FIELD_ERROR')) {
        console.error('[DB ERROR] Missing column in users table:', dbErr.message);
        return res.status(500).json({ error: 'Database error: missing column in users table.' });
      }
      return res.status(500).json({ error: 'Database error: ' + dbErr.message });
    }
  } catch (err) {
    console.error('[AUTH ERROR] Registration failed:', err.message);
    next(err);
  }
});

// Login (all roles)
router.post('/login', async (req, res, next) => {
  const startTime = Date.now();
  try {
    console.log('[AUTH] ðŸ” Login attempt started:', { email: req.body.email });
    
    const { email, password } = req.body;
    
    if (!email || !password) {
      console.log('[AUTH] âŒ Missing email or password');
      return res.status(400).json({ error: 'Email and password required' });
    }
    
    // Step 1: Query user (with timeout)
    console.log('[AUTH] ðŸ“Š Querying user...');
    let users;
    try {
      [users] = await Promise.race([
        pool.query('SELECT * FROM users WHERE email = ?', [email]),
        new Promise((_, reject) => setTimeout(() => reject(new Error('Database query timeout')), 5000))
      ]);
    } catch (dbErr) {
      console.error('[AUTH] âŒ Query users failed:', dbErr.message);
      if (dbErr.message.includes('ER_NO_SUCH_TABLE')) {
        console.error("[AUTH] ðŸ”§ 'users' table missing. Creating...");
        try {
          await pool.query(`CREATE TABLE IF NOT EXISTS users (
            id INT AUTO_INCREMENT PRIMARY KEY,
            name VARCHAR(255),
            email VARCHAR(255) UNIQUE,
            password VARCHAR(255),
            role VARCHAR(32),
            phone VARCHAR(32),
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          )`);
          console.log("[AUTH] âœ… 'users' table created.");
          return res.status(400).json({ error: 'User table was missing. Please try again.' });
        } catch (createErr) {
          console.error('[AUTH] âŒ Failed to create users table:', createErr.message);
          return res.status(500).json({ error: 'Database error: users table missing and could not be created.' });
        }
      } else {
        return res.status(500).json({ error: 'Database error: ' + dbErr.message });
      }
    }
    
    if (!users || users.length === 0) {
      console.log('[AUTH] âŒ User not found:', email);
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    const user = users[0];
    console.log('[AUTH] âœ… User found:', { id: user.id, role: user.role });
    
    // Step 2: Password verification (with timeout and optimization)
    console.log('[AUTH] ðŸ”’ Verifying password...');
    let match;
    try {
      match = await Promise.race([
        bcrypt.compare(password, user.password),
        new Promise((_, reject) => setTimeout(() => reject(new Error('Password verification timeout')), 10000))
      ]);
    } catch (bcryptErr) {
      console.error('[AUTH] âŒ Password verification failed:', bcryptErr.message);
      if (bcryptErr.message.includes('timeout')) {
        return res.status(500).json({ error: 'Authentication timeout. Please try again.' });
      }
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    if (!match) {
      console.log('[AUTH] âŒ Password mismatch for user:', email);
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Step 3: Agent profile check (async, non-blocking)
    if (user.role === 'agent') {
      console.log('[AUTH] ðŸ¤– Checking agent profile...');
      // Don't await this - do it asynchronously to not block login
      setImmediate(async () => {
        try {
          const [agentProfile] = await pool.query('SELECT id FROM agents WHERE user_id = ?', [user.id]);
          if (agentProfile.length === 0) {
            console.log(`[AUTH] ðŸ”§ Creating agent profile for user ${user.id}...`);
            await pool.query(`
              INSERT INTO agents (user_id, first_name, last_name, email, phone, status, agent_type)
              VALUES (?, ?, ?, ?, ?, 'offline', NULL)
            `, [
              user.id,
              user.name.split(' ')[0] || '',
              user.name.split(' ')[1] || '',
              user.email,
              user.phone
            ]);
            console.log(`[AUTH] âœ… Agent profile created for user ${user.id}.`);
          }
        } catch (agentErr) {
          console.error(`[AUTH] âŒ Failed to auto-create agent profile for user ${user.id}:`, agentErr.message);
        }
      });
    }
    
    // Step 4: Generate JWT token
    console.log('[AUTH] ðŸŽ« Generating token...');
    const token = jwt.sign(
      { id: user.id, role: user.role, name: user.name }, 
      process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-this-in-production', 
      { expiresIn: '7d' }
    );
    
    const loginTime = Date.now() - startTime;
    console.log(`[AUTH] âœ… Login successful in ${loginTime}ms:`, { id: user.id, email: user.email, role: user.role });
    
    // Get agent type if user is an agent
    let agentType = null;
    if (user.role === 'agent') {
      try {
        const [agentData] = await pool.query('SELECT agent_type FROM agents WHERE user_id = ?', [user.id]);
        if (agentData.length > 0) {
          agentType = agentData[0].agent_type;
        }
      } catch (agentErr) {
        console.warn('[AUTH] Could not fetch agent type:', agentErr.message);
      }
    }
    
    return res.json({ 
      token, 
      user: { 
        id: user.id, 
        name: user.name, 
        email: user.email, 
        role: user.role, 
        phone: user.phone,
        agent_type: agentType
      } 
    });
    
  } catch (err) {
    const loginTime = Date.now() - startTime;
    console.error(`[AUTH] âŒ Login failed after ${loginTime}ms:`, err.message);
    return res.status(500).json({ error: 'Authentication error. Please try again.' });
  }
});

// Auth middleware
function requireAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader) return res.status(401).json({ error: 'No token' });
  const token = authHeader.split(' ')[1];
  try {
    req.user = jwt.verify(token, process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-this-in-production');
    next();
  } catch {
    res.status(401).json({ error: 'Invalid token' });
  }
}

// Role middleware
function requireRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Forbidden: insufficient role' });
    }
    next();
  };
}

// Profile (all roles)
router.get('/profile', requireAuth, async (req, res, next) => {
  try {
    const [users] = await pool.query('SELECT id, name, email, role, phone, address, city, country FROM users WHERE id = ?', [req.user.id]);
    if (users.length === 0) return res.status(404).json({ error: 'User not found' });
    res.json(users[0]);
  } catch (err) {
    next(err);
  }
});

// Auth check endpoint
router.get('/check', (req, res) => {
  const authHeader = req.headers.authorization;
  if (!authHeader) {
    console.warn('[AUTH] /api/auth/check: No token provided');
    return res.status(401).json({ error: 'No token' });
  }
  const token = authHeader.split(' ')[1];
  try {
    const user = jwt.verify(token, process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-this-in-production');
    console.log('[AUTH] /api/auth/check: Token valid for user:', user);
    res.json(user);
  } catch (err) {
    console.warn('[AUTH] /api/auth/check: Invalid or expired token:', err.message);
    if (process.env.NODE_ENV === 'development') console.error(err.stack);
    res.status(401).json({ error: 'Invalid or expired token' });
  }
});

// Token validation endpoint (used by frontend auth-utils.js)
router.get('/validate', async (req, res) => {
  const authHeader = req.headers.authorization;
  if (!authHeader) {
    console.warn('[AUTH] /api/auth/validate: No token provided');
    return res.status(401).json({ success: false, error: 'No token provided' });
  }
  
  const token = authHeader.split(' ')[1];
  if (!token) {
    console.warn('[AUTH] /api/auth/validate: Invalid token format');
    return res.status(401).json({ success: false, error: 'Invalid token format' });
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-this-in-production');
    console.log('[AUTH] /api/auth/validate: Token valid for user:', decoded.id);
    
    // Get fresh user data from database
    try {
      const [users] = await pool.query('SELECT id, name, email, role, phone FROM users WHERE id = ?', [decoded.id]);
      if (users.length === 0) {
        console.warn('[AUTH] /api/auth/validate: User not found in database:', decoded.id);
        return res.status(401).json({ success: false, error: 'User not found' });
      }
      
      const user = users[0];
      console.log('[AUTH] /api/auth/validate: User data refreshed:', { id: user.id, role: user.role });
      
      // Get agent type if user is an agent
      let agentType = null;
      if (user.role === 'agent') {
        try {
          const [agentData] = await pool.query('SELECT agent_type FROM agents WHERE user_id = ?', [user.id]);
          if (agentData.length > 0) {
            agentType = agentData[0].agent_type;
          }
        } catch (agentErr) {
          console.warn('[AUTH] Could not fetch agent type for validation:', agentErr.message);
        }
      }
      
      res.json({ 
        success: true, 
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          role: user.role,
          phone: user.phone,
          agent_type: agentType
        }
      });
    } catch (dbErr) {
      console.error('[AUTH] /api/auth/validate: Database error:', dbErr.message);
      res.status(500).json({ success: false, error: 'Database error' });
    }
  } catch (err) {
    console.warn('[AUTH] /api/auth/validate: Invalid or expired token:', err.message);
    res.status(401).json({ success: false, error: 'Invalid or expired token' });
  }
});

module.exports = { router, requireAuth, requireRole }; 